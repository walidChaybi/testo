package fr.gouv.diplomatie.rece.etatcivil.adapters.rest.controllers;

import fr.gouv.diplomatie.rece.commun.bo.Result;
import fr.gouv.diplomatie.rece.commun.constants.SecurityConstants;
import fr.gouv.diplomatie.rece.commun.exceptions.BusinessListException;
import fr.gouv.diplomatie.rece.commun.exceptions.PayloadTooLargeException;
import fr.gouv.diplomatie.rece.commun.utils.RecuperationHeaderUtils;
import fr.gouv.diplomatie.rece.commun.web.handlers.GlobalDefaultExceptionHandler;
import fr.gouv.diplomatie.rece.etatcivil.adapters.rest.mappers.MapperActeSigneDomainToDto;
import fr.gouv.diplomatie.rece.etatcivil.adapters.rest.mappers.MapperDomainToDto;
import fr.gouv.diplomatie.rece.etatcivil.adapters.rest.mappers.MapperDtoToDomain;
import fr.gouv.diplomatie.rece.etatcivil.adapters.rest.utils.ControllerUtils;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.in.ActeDoubleNumeriqueTraitement;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.in.ActeTraitement;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.in.DeleteAlerteActeCommand;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.in.MentionTraitement;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.in.RmcAutoTraitement;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.in.RmcTraitement;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.in.SaisieExtraitCommand;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.in.projetActe.MiseAJourActeTraitement;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.in.rmccommand.RmcAutoCommand;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.in.rmccommand.RmcCommand;
import fr.gouv.diplomatie.rece.etatcivil.domain.enums.NatureActe;
import fr.gouv.diplomatie.rece.etatcivil.domain.enums.TechnicalExceptionCode;
import fr.gouv.diplomatie.rece.etatcivil.domain.enums.TypeExtrait;
import fr.gouv.diplomatie.rece.etatcivil.domain.repertoirecivil.acte.Acte;
import fr.gouv.diplomatie.rece.etatcivil.domain.repertoirecivil.acte.ActeImage;
import fr.gouv.diplomatie.rece.etatcivil.domain.repertoirecivil.acte.AlerteActe;
import fr.gouv.diplomatie.rece.etatcivil.domain.repertoirecivil.acte.BulletinIdentification;
import fr.gouv.diplomatie.rece.etatcivil.domain.repertoirecivil.acte.TitulaireAnalyseMarginale;
import fr.gouv.diplomatie.rece.etatcivil.domain.repertoirecivil.commun.Titulaire;
import fr.gouv.diplomatie.rece.etatcivil.domain.repertoirecivil.mention.Mention;
import fr.gouv.diplomatie.rece.etatcivil.domain.repertoirecivil.rmc.ResultatRmcActe;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.acte.ActeDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.acte.ActeImageDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.acte.AlerteActeDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.acte.BulletinIdentificationDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.acte.CorpsExtraitDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.acte.DocumentActeImageDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.acte.DonneesTeleverificationDTO;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.acte.ListeAlerteActeDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.acte.LotActeImageDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.acte.MiseAjourActeDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.acte.ResultActeSigneDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.acte.TitulaireAnalyseMarginaleDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.commun.TitulaireDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.mention.MentionDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.repertoirecivil.sasisieextrait.SaisieExtraitDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.rmc.RmcActeReponseDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.rmc.requete.RmcAutoFiltreTitulaireRequestDTO;
import fr.gouv.diplomatie.rece.etatcivil.dto.rmc.requete.RmcRequestDto;
import fr.gouv.diplomatie.rece.etatcivil.dto.signature.DocumentSigneDTO;
import fr.gouv.diplomatie.rece.etatcivil.dto.signature.SignatureCompositionRecord;
import fr.gouv.diplomatie.rece.etatcivil.enums.StatutMention;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiResponse;
import io.swagger.annotations.ApiResponses;
import jakarta.persistence.PersistenceException;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.jetbrains.annotations.NotNull;
import org.springframework.core.io.InputStreamResource;
import org.springframework.data.domain.Page;
import org.springframework.http.ContentDisposition;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.transaction.TransactionTimedOutException;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

@RestController
@RequestMapping(value = "/v1/acte", produces = {MediaType.APPLICATION_JSON_VALUE}, consumes = {MediaType.APPLICATION_JSON_VALUE})
@RequiredArgsConstructor
public class ActeController {

	private static final String LABEL_ACCEPT_RANGE = "rmc_acte";

	private final ControllerUtils controllerUtils;

	private final ActeTraitement acteTraitement;

	private final RmcTraitement rmcTraitement;

	private final RmcAutoTraitement rmcAutoTraitement;

	private final MentionTraitement mentionTraitement;

	private final MiseAJourActeTraitement miseAJourActeService;

	private final MapperDomainToDto mapperDomainToDto;

	private final MapperDtoToDomain mapperDtoToDomain;

	private final MapperActeSigneDomainToDto mapperActeSigneDomainToDto;

	private final ActeDoubleNumeriqueTraitement acteDoubleNumeriqueTraitement;

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Recherche un acte avec des critères")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@PostMapping(value = "/rmc")
	public ResponseEntity<Result<List<RmcActeReponseDto>>> rechercheMultiCriteres(@RequestBody final RmcRequestDto rmcRequestDto,
																				  @RequestParam(defaultValue = "0-10") final String range, final HttpServletRequest request) {

		Pair<Integer, Integer> offsetLimit = controllerUtils.definirOffsetLimit(range);
		final Map<RmcCommand, BusinessListException> mapErreurActe = new HashMap<>();

		RmcCommand rmcCommand = controllerUtils.buildRMCCommand(rmcRequestDto, offsetLimit.getLeft(),
																offsetLimit.getRight());

		// Pour les RMC, un code HTTP 413 est renvoyé si celle-ci est trop longue à la place d'un code 408
		try {
			Page<ResultatRmcActe> rmcActes = rmcTraitement.rmcActes(rmcCommand,
																	RecuperationHeaderUtils.getIdArobasFromHttpRequete(request), mapErreurActe);

			return getResultResponseEntity(offsetLimit, rmcActes, mapErreurActe);
		} catch (TransactionTimedOutException ex) {
			throw new PayloadTooLargeException(TechnicalExceptionCode.TECH_TIMEOUT_TRANSACTION_RMC, rmcCommand.toString());
		} catch (PersistenceException ex) {
			if (ex.getCause() != null && GlobalDefaultExceptionHandler.HIBERNATE_TIMEOUT_EXCEPTION_MESSAGE.equals(ex.getCause().getMessage())) {
				throw new PayloadTooLargeException(TechnicalExceptionCode.TECH_TIMEOUT_TRANSACTION_RMC, rmcCommand.toString());
			}
		}

		return null;
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Recherche auto d'un acte avec des critères")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@PostMapping(value = "/rmcauto")
	public ResponseEntity<Result<List<RmcActeReponseDto>>> rechercheMultiCriteresAuto(
			@RequestBody final List<RmcAutoFiltreTitulaireRequestDTO> criteres, @RequestParam(defaultValue = "0-10") final String range,
			final HttpServletRequest request) {

		Pair<Integer, Integer> offsetLimit = controllerUtils.definirOffsetLimit(range);
		final Map<RmcCommand, BusinessListException> mapErreurActe = new HashMap<>();

		RmcAutoCommand rmcAutoCommand = mapperDtoToDomain.map(criteres, offsetLimit.getLeft(),
															  offsetLimit.getRight());

		// Pour les RMC, un code HTTP 413 est renvoyé si celle-ci est trop longue à la place d'un code 408
		try {
			Page<ResultatRmcActe> rmcActes = rmcAutoTraitement.rechercheAutoActes(rmcAutoCommand,
																				  RecuperationHeaderUtils.getIdArobasFromHttpRequete(request));

			return getResultResponseEntity(offsetLimit, rmcActes, mapErreurActe);
		} catch (TransactionTimedOutException ex) {
			throw new PayloadTooLargeException(TechnicalExceptionCode.TECH_TIMEOUT_TRANSACTION_RMC, rmcAutoCommand.toString());
		} catch (PersistenceException ex) {
			if (ex.getCause() != null && GlobalDefaultExceptionHandler.HIBERNATE_TIMEOUT_EXCEPTION_MESSAGE.equals(ex.getCause().getMessage())) {
				throw new PayloadTooLargeException(TechnicalExceptionCode.TECH_TIMEOUT_TRANSACTION_RMC, rmcAutoCommand.toString());
			}
		}
		return null;
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Récupère un acte Image PDF")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@GetMapping(value = "/{id}/corps-image", consumes = {MediaType.ALL_VALUE})
	public Result<DocumentActeImageDto> getCorpsActeImageById(@PathVariable final UUID id,
															  final HttpServletRequest request) {
		return new Result<>(acteTraitement.getActeImage(id,
														RecuperationHeaderUtils.getIdArobasFromHttpRequete(request)));
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Récupère les données pour générer un acte texte PDF")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@GetMapping(value = "/{id}/donnees-pour-composition-acte-texte", consumes = {MediaType.ALL_VALUE})
	public ResponseEntity<Result<String>> getDonneesPourCompositionActeTexteById(@PathVariable final String id,
																				 final HttpServletRequest request) {

		String acteTexteJson = acteTraitement.getCorpsActeTexte(UUID.fromString(id),
																RecuperationHeaderUtils.getIdArobasFromHttpRequete(request),
																false);

		return new ResponseEntity<>(new Result<>(acteTexteJson), HttpStatus.OK);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Récupère les données pour générer un acte texte PDF mis à jour")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@GetMapping(value = "/{id}/donnees-pour-composition-acte-texte-mis-a-jour", consumes = {MediaType.ALL_VALUE})
	public ResponseEntity<Result<String>> getDonneesPourCompositionActeTexteMisAJourById(@PathVariable final String id,
																						 final HttpServletRequest request) {

		String acteTexteJson = acteTraitement.getCorpsActeTexte(UUID.fromString(id),
																RecuperationHeaderUtils.getIdArobasFromHttpRequete(request), true);

		return new ResponseEntity<>(new Result<>(acteTexteJson), HttpStatus.OK);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Récupère les données pour générer un acte repris Texte PDF")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@GetMapping(value = "/{id}/donnees-pour-composition-acte-repris", consumes = {MediaType.ALL_VALUE})
	public ResponseEntity<Result<String>> getDonneesPourCompositionActeReprisById(@PathVariable final String id,
																				  final HttpServletRequest request) {
		final String acteTexteJson = acteTraitement.getActeReprisTexte(UUID.fromString(id),
																	   RecuperationHeaderUtils.getIdArobasFromHttpRequete(request));
		return new ResponseEntity<>(new Result<>(acteTexteJson), HttpStatus.OK);
	}

	private ResponseEntity<Result<InputStreamResource>> getResponseEntityForInputStream(final byte[] corps) {
		HttpHeaders responseHeaders = new HttpHeaders();
		InputStream inputStream = new ByteArrayInputStream(corps);
		InputStreamResource inputStreamResource = new InputStreamResource(inputStream);

		responseHeaders.setContentLength(corps.length);
		responseHeaders.setContentType(MediaType.APPLICATION_PDF);
		responseHeaders.setContentDisposition(ContentDisposition.builder("attachment")
																.filename("acte.pdf")
																.build());

		return ResponseEntity.ok()
							 .headers(responseHeaders)
							 .body(new Result<>(inputStreamResource));
	}


	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Récupère le bulletin d'identification d'un acte")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 404, message = "Pas d'acte correspondant", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@GetMapping(value = "/bulletinIdentification/{id}", consumes = {MediaType.ALL_VALUE})
	public ResponseEntity<Result<BulletinIdentificationDto>> getBulletinIdentification(@PathVariable final UUID id,
																					   @RequestParam(defaultValue = "false") boolean recupereImagesEtTexte,
																					   @RequestParam(defaultValue = "false") boolean isConsultation,
																					   final HttpServletRequest request) {
		final BulletinIdentification bulletinIdentification = acteTraitement.getBulletinIdentification(id, recupereImagesEtTexte, isConsultation, RecuperationHeaderUtils.getIdArobasFromHttpRequete(request));
		final BulletinIdentificationDto bulletinIdentificationDto = mapperDomainToDto.mapBulletinIdentification(bulletinIdentification);
		return new ResponseEntity<>(new Result<>(bulletinIdentificationDto), HttpStatus.OK);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Recherche le titulaire de l'analyse marginale par idActe")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 404, message = "Pas d'acte correspondant", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@PostMapping(value = "/analyseMarginale", consumes = {MediaType.APPLICATION_JSON_VALUE})
	public ResponseEntity<Result<List<TitulaireAnalyseMarginaleDto>>> getTitulaireAnalyseMarginaleByIdActe(@RequestBody final List<UUID> listIdsActe,
																										   @RequestParam(defaultValue = "false") boolean recupereImagesEtTexte,
																										   @RequestParam(defaultValue = "false") boolean isConsultation,
																										   final HttpServletRequest request) {

		final List<TitulaireAnalyseMarginale> titulaireAnalyseMarginales = acteTraitement.getTitulairesAnalysesMarginalesByIdActe(listIdsActe, recupereImagesEtTexte, isConsultation,
																																  RecuperationHeaderUtils.getIdArobasFromHttpRequete(request));

		final List<TitulaireAnalyseMarginaleDto> titulaireAnalyseMarginaleDtos = mapperDomainToDto.mapTitulairesAnalysesMarginales(titulaireAnalyseMarginales);

		return new ResponseEntity<>(new Result<>(titulaireAnalyseMarginaleDtos), HttpStatus.OK);

	}

	@PreAuthorize("estProfilReceUser(#request) ")
	@ApiOperation(value = "Recherche un resumé d'acte par son identifiant")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 404, message = "Pas de resume d'acte correspondant", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@GetMapping(value = "/{id}/resume", consumes = {MediaType.ALL_VALUE})
	public ResponseEntity<Result<ActeDto>> getResumeActeById(@PathVariable final String id,
															 @RequestParam(defaultValue = "false") boolean recupereImagesEtTexte,
															 @RequestParam(defaultValue = "true") boolean remplaceIdentiteTitulaireParIdentiteTitulaireAM,
															 final HttpServletRequest request) {

		final Acte acte = acteTraitement.getActeResumeById(UUID.fromString(id), recupereImagesEtTexte, true,
														   remplaceIdentiteTitulaireParIdentiteTitulaireAM,
														   RecuperationHeaderUtils.getIdArobasFromHttpRequete(request));
		final ActeDto acteDto = mapperDomainToDto.mapActe(acte);
		return new ResponseEntity<>(new Result<>(acteDto), HttpStatus.OK);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Récupération des données de téléverification")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 404, message = "Pas de resume d'acte correspondant", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@PostMapping(value = "/donnees-pour-televerification", consumes = {MediaType.APPLICATION_JSON_VALUE})
	public Result<List<DonneesTeleverificationDTO>> getDonneesTeleverification(@RequestBody final List<UUID> listIdsActes,
																			   final HttpServletRequest request) {

		return new Result<>(mapperDomainToDto.map(acteTraitement.getDonneesTeleverification(listIdsActes,
																							RecuperationHeaderUtils.getIdArobasFromHttpRequete(request))));
	}


	@PreAuthorize("estBatch(#request)")
	@ApiOperation(value = "Retourne une liste d'actes images à reprendre")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class),
			@ApiResponse(code = 503, message = "Service indisponible", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@GetMapping(value = "/actesimages", consumes = {MediaType.ALL_VALUE})
	public ResponseEntity<Result<List<LotActeImageDto>>> getActesImages(
			@RequestParam(defaultValue = "0-100") final String range, @RequestParam final NatureActe natureActe,
			final HttpServletRequest request) {
		Pair<Integer, Integer> offsetLimit = controllerUtils.definirOffsetLimit(range);
		Page<ActeImage> actesImages = acteTraitement.getActesImages(range, natureActe);
		List<ActeImageDto> actesImagesDto = mapperDomainToDto.mapActeImages(actesImages.getContent());

		List<LotActeImageDto> lots = getLotActeImageDtos(actesImagesDto);

		HttpStatus status = controllerUtils.definirHttpStatus(actesImages);
		HttpHeaders httpHeaders = controllerUtils.definirPaginationHeader(actesImages, offsetLimit.getRight(),
																		  LABEL_ACCEPT_RANGE);
		return new ResponseEntity<>(new Result<>(lots), httpHeaders, status);
	}

	private static @NotNull List<LotActeImageDto> getLotActeImageDtos(List<ActeImageDto> actesImagesDto) {
		if (null != actesImagesDto && !actesImagesDto.isEmpty()) {
			Map<UUID, List<ActeImageDto>> actesImagesParIdActe = actesImagesDto.stream().collect(Collectors.groupingBy(ActeImageDto::getIdActe));
			return actesImagesParIdActe.values().stream().filter(Objects::nonNull).map(acteImageDtos -> LotActeImageDto.builder()
																													   .idActe(acteImageDtos.get(0).getIdActe())
																													   .dateCreationActe(acteImageDtos.get(0).getDateCreationActe())
																													   .numeroActe(acteImageDtos.get(0).getNumeroActe())
																													   .natureActe(acteImageDtos.get(0).getNatureActe())
																													   .images(acteImageDtos).build()
			).toList();
		}
		return List.of();
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Recherche des alertes associées à un acte")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class),
			@ApiResponse(code = 503, message = "Service indisponible", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@GetMapping(value = "{idActe}/alertes", consumes = {MediaType.ALL_VALUE})
	public Result<ListeAlerteActeDto> getAlertesActe(@PathVariable(name = "idActe") final UUID idActe,
													 final HttpServletRequest request) {
		// Récupération des alertes
		List<AlerteActe> alertesActe = acteTraitement.getAlertesActe(idActe);
		// Récupération de l'ID TypeRegistre
		UUID idTypeRegistre = acteTraitement.getIdTypeRegistre(idActe);

		ListeAlerteActeDto listeAlertesActeDTO = mapperDomainToDto.mapListeAlertesActe(idTypeRegistre, alertesActe);
		return new Result<>(listeAlertesActeDTO);
	}

	//TODO A deplacer dans une nouvelle class controller "v1/alerte" - Impact front + batch
	@PreAuthorize("estProfilReceUser(#request) || estBatch(#request)")
	@ApiOperation(value = "Ajout d'une alerte sur un acte")
	@ApiResponses(value = {
			@ApiResponse(code = 201, message = "Objet créé", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class),
			@ApiResponse(code = 503, message = "Service indisponible", response = Result.class)})
	@ResponseStatus(value = HttpStatus.CREATED)
	@PostMapping(value = "/alerte")
	public Result<AlerteActeDto> addAlerteActe(@RequestBody final AlerteActeDto alerteActeDto, final HttpServletRequest request) {

		boolean hasToGetIdArobas = StringUtils.contains(request.getHeader(SecurityConstants.HEADER_REFERER),
														SecurityConstants.RECE_UI_REFERER);

		AlerteActeDto alerteActeDTO;
		if (hasToGetIdArobas) {
			String idArobas = RecuperationHeaderUtils.getIdArobasFromHttpRequete(request);
			alerteActeDTO = mapperDomainToDto.mapAlerteActe(acteTraitement
																	.addAlerteActe(mapperDtoToDomain.mapAlerteActe(alerteActeDto), idArobas));
		} else {
			alerteActeDTO = mapperDomainToDto
					.mapAlerteActe(acteTraitement.addAlerteActe(mapperDtoToDomain.mapAlerteActe(alerteActeDto)));
		}

		return new Result<>(alerteActeDTO);
	}

	//TODO A deplacer dans une nouvelle class controller "v1/alerte" - Impact front
	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Suppression d'une alerte sur un acte")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class),
			@ApiResponse(code = 503, message = "Service indisponible", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@DeleteMapping(value = "/alerte/{idAlerteActe}", consumes = {MediaType.ALL_VALUE})
	public Result<Void> deleteAlerteActe(@PathVariable final UUID idAlerteActe, final HttpServletRequest request) {

		DeleteAlerteActeCommand deleteAlerteActeCommand = DeleteAlerteActeCommand.builder()
																				 .idAlerteActe(idAlerteActe)
																				 .build();

		String idArobas = RecuperationHeaderUtils.getIdArobasFromHttpRequete(request);

		acteTraitement.deleteAlerteActe(deleteAlerteActeCommand, idArobas);

		return new Result<>(null);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Recherche les titulaires d'un acte par son identifiant")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@GetMapping(value = "/{id}/titulaire", consumes = {MediaType.ALL_VALUE})
	public ResponseEntity<Result<Set<TitulaireDto>>> recupererTitulairesActe(@PathVariable final UUID id,
																			 final HttpServletRequest request) {
		Set<Titulaire> titulaires = acteTraitement.getTitulairesActe(id);
		return new ResponseEntity<>(new Result<>(mapperDomainToDto.mapSetTitulaires(titulaires)), HttpStatus.OK);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Récupère les mentions d'un acte")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class),
			@ApiResponse(code = 503, message = "Service indisponible", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@GetMapping(value = "/{idActe}/mentions", consumes = {MediaType.ALL_VALUE})
	public ResponseEntity<Result<List<MentionDto>>> getMentionsActe(@PathVariable final UUID idActe,
																	@RequestParam(required = false) final StatutMention statut,
																	final HttpServletRequest request) {
		final List<Mention> mentions = mentionTraitement.getMentionsByIdActe(idActe, mapperDtoToDomain.mapStatutMention(statut));
		final List<MentionDto> mentionsDtos = mapperDomainToDto.mapMentions(mentions);
		return new ResponseEntity<>(new Result<>(mentionsDtos), HttpStatus.OK);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Ajout / suppression / mise à jour des mentions d'un acte en délivrance")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class),
			@ApiResponse(code = 503, message = "Service indisponible", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@PostMapping(value = "/{idActe}/mentions")
	public Result<Void> miseAJourMentionActePourDelivrance(@RequestBody final List<MentionDto> mentionsDto,
														   @PathVariable final UUID idActe, final HttpServletRequest request) {

		final String idArobas = RecuperationHeaderUtils.getIdArobasFromHttpRequete(request);

		mentionTraitement.miseAJourMentions(mapperDtoToDomain.mapMentions(mentionsDto), idActe, idArobas);

		return new Result<>(null);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Ajout / suppression / mise à jour des mentions d'un acte en création d'acte")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class),
			@ApiResponse(code = 503, message = "Service indisponible", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@PutMapping(value = "/mentions-et-analyse-marginale")
	public Result<String> miseAJourMentionEtAnalyseMarginale(@RequestBody final MiseAjourActeDto miseAjourActeDto,
															 final HttpServletRequest request) {

		final String idArobas = RecuperationHeaderUtils.getIdArobasFromHttpRequete(request);

		miseAJourActeService.miseAJour(mapperDtoToDomain.mapMiseAjourActe(miseAjourActeDto), idArobas);

		return new Result<>(acteTraitement.getCorpsActeTexte(miseAjourActeDto.getIdActe(), idArobas, true));
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Abandon de la mise à jour d'un acte")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class),
			@ApiResponse(code = 503, message = "Service indisponible", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@PatchMapping(value = "/{idActe}/abandonner-mise-a-jour")
	public Result<Void> abandonMiseAJourActe(@PathVariable final UUID idActe,
											 final HttpServletRequest request) {

		final String idArobas = RecuperationHeaderUtils.getIdArobasFromHttpRequete(request);

		mentionTraitement.abandonMiseAJourMentionsActe(idActe, idArobas);

		return new Result<>(null);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Remplace la date de dernière delivrance par aujourd'hui")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class),
			@ApiResponse(code = 503, message = "Service indisponible", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@PatchMapping(value = "/{idActe}/dernieredelivrance", consumes = {MediaType.ALL_VALUE})
	public Result<Void> miseAJourDerniereDelivranceActe(@PathVariable final UUID idActe,
														final HttpServletRequest request) {

		String idArobas = RecuperationHeaderUtils.getIdArobasFromHttpRequete(request);

		acteTraitement.miseAJourDerniereDelivrance(idActe, idArobas);

		return new Result<>(null);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Mise à jour des informations suite à la saisie de l'extrait d'un acte")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class),
			@ApiResponse(code = 503, message = "Service indisponible", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@PatchMapping(value = "/{idActe}/saisieExtrait")
	public Result<Void> miseAJourSuiteSaisieExtrait(@PathVariable final UUID idActe,
													@RequestBody final SaisieExtraitDto saisieExtraitDto,
													final HttpServletRequest request) {

		String idArobas = RecuperationHeaderUtils.getIdArobasFromHttpRequete(request);
		SaisieExtraitCommand saisieExtraitCommand = SaisieExtraitCommand.builder().idActe(idActe)
																		.idAnalyseMarginale(saisieExtraitDto.getIdAnalyseMarginale())
																		.natureActe(mapperDtoToDomain.mapNatureActe(saisieExtraitDto.getNatureActe()))
																		.titulaire1(mapperDtoToDomain.mapSaisieExtraitTitulaireActe(saisieExtraitDto.getTitulaire1()))
																		.titulaire2(mapperDtoToDomain.mapSaisieExtraitTitulaireActe(saisieExtraitDto.getTitulaire2()))
																		.titulaireOrigine1(mapperDtoToDomain.mapSaisieExtraitTitulaireActe(saisieExtraitDto.getTitulaireOrigine1()))
																		.titulaireOrigine2(mapperDtoToDomain.mapSaisieExtraitTitulaireActe(saisieExtraitDto.getTitulaireOrigine2()))
																		.evenement(mapperDtoToDomain.mapEvenement(saisieExtraitDto.getEvenementActe()))
																		.detailMariage(mapperDtoToDomain.mapDetailMariage(saisieExtraitDto.getDetailMariage())).build();

		acteTraitement.miseAJourSuiteSaisieExtrait(saisieExtraitCommand, idArobas);

		return new Result<>(null);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Enregistre le corps de l'extrait rectifié")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 404, message = "Pas d'acte correspondant", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@PostMapping(value = "/{idActe}/corpstexte")
	public Result<Void> sauvegardeCorpsExtrait(@PathVariable final UUID idActe,
											   @RequestBody CorpsExtraitDto corpsExtrait,
											   @RequestParam final TypeExtrait type, final HttpServletRequest request) {
		acteTraitement.sauvegardeCorpsExtrait(idActe, corpsExtrait.getCorpsExtrait(), type,
											  RecuperationHeaderUtils.getIdArobasFromHttpRequete(request));
		return new Result<>(null);
	}

	private ResponseEntity<Result<List<RmcActeReponseDto>>> getResultResponseEntity(final Pair<Integer, Integer> offsetLimit,
																					final Page<ResultatRmcActe> rmcActes,
																					final Map<RmcCommand, BusinessListException> mapErreurActe) {
		HttpStatus status = controllerUtils.definirHttpStatus(rmcActes);
		HttpHeaders httpHeaders = controllerUtils.definirPaginationHeader(rmcActes, offsetLimit.getRight(), LABEL_ACCEPT_RANGE);
		Result<List<RmcActeReponseDto>> result = new Result<>();
		if (!mapErreurActe.isEmpty()) {
			mapErreurActe.values().forEach(result::addErrors);
		}
		if (rmcActes != null) {
			result.setData(mapperDomainToDto.mapRmcActes(rmcActes.getContent()));
		}
		return new ResponseEntity<>(result, httpHeaders, status);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Composition document final à signer")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 404, message = "Pas d'acte correspondant", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@GetMapping("/{idActe}/recomposer-document-final")
	public ResponseEntity<Result<InputStreamResource>> recomposerActeSigne(@PathVariable UUID idActe,
																		   final HttpServletRequest request) {
		String idArobas = RecuperationHeaderUtils.getIdArobasFromHttpRequete(request);
		final byte[] acteSigne = acteTraitement.recomposerActeSigne(idActe, idArobas);
		return getResponseEntityForInputStream(acteSigne);
	}

	@PreAuthorize("estBatch(#request)")
	@ApiOperation(value = "Récupérer les actes signés liés à un numéro de dossier national")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 404, message = "Pas d'acte correspondant", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@GetMapping(value = "/numero-dossier-national/{numeroDossierNational}", consumes = {MediaType.ALL_VALUE})
	public ResponseEntity<Result<List<ResultActeSigneDto>>> getActesSignesByNumeroDossierNational(@PathVariable final String numeroDossierNational,
																								  final HttpServletRequest request) {
		return new ResponseEntity<>(new Result<>(mapperActeSigneDomainToDto
														 .mapActes(acteTraitement.getActesSignesByNumeroDossierNational(numeroDossierNational))), HttpStatus.OK);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Composition document mentions ultérieures à signer")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 404, message = "Pas d'acte correspondant", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@PatchMapping("/{idActe}/composer-document-mentions-ulterieures")
	public ResponseEntity<Result<String>> composerDocumentMentionsUlterieures(@RequestBody SignatureCompositionRecord signature,
																			  @PathVariable UUID idActe,
																			  final HttpServletRequest request) {
		return new ResponseEntity<>(new Result<>(mentionTraitement.composerDocumentMentionsUlterieures(idActe, mapperDtoToDomain.mapSignatureComposition(signature),
																									   RecuperationHeaderUtils.getIdArobasFromHttpRequete(request))), HttpStatus.OK);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Intégration du document mention signé")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 404, message = "Pas d'acte correspondant", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@PatchMapping("/{idActe}/integrer-document-mention-signe")
	public ResponseEntity<Result<String>> integrerDocumentMentionSigne(@RequestBody DocumentSigneDTO documentSigneDTO,
																	   @PathVariable UUID idActe,
																	   final HttpServletRequest request) {
		String idArobas = RecuperationHeaderUtils.getIdArobasFromHttpRequete(request);
		mentionTraitement.integrerDocumentMentionSigne(idActe, idArobas, mapperDtoToDomain.map(documentSigneDTO));
		return new ResponseEntity<>(new Result<>(), HttpStatus.OK);
	}

	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Composition d'un acte électronique à partir d'un acte issu d'un support papier")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 404, message = "Pas d'acte correspondant", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@ResponseBody
	@PatchMapping("/{idActe}/double-numerique/composer-document-final")
	public ResponseEntity<Result<String>> composerActeDoubleNumerique(@RequestBody SignatureCompositionRecord signature,
																	  @PathVariable UUID idActe,
																	  final HttpServletRequest request) {
		String idArobas = RecuperationHeaderUtils.getIdArobasFromHttpRequete(request);
		return new ResponseEntity<>(new Result<>(acteDoubleNumeriqueTraitement.composerActeDoubleNumerique(idActe,
																										   mapperDtoToDomain.mapSignatureComposition(signature),
																										   idArobas)),
									HttpStatus.OK);
	}


	@PreAuthorize("estProfilReceUser(#request)")
	@ApiOperation(value = "Intégration du document acte double numérique signé")
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = "OK", response = Result.class),
			@ApiResponse(code = 400, message = "Erreur fonctionnelle", response = Result.class),
			@ApiResponse(code = 403, message = "Erreur de droit", response = Result.class),
			@ApiResponse(code = 404, message = "Pas d'acte correspondant", response = Result.class),
			@ApiResponse(code = 500, message = "Erreur interne", response = Result.class)})
	@ResponseStatus(value = HttpStatus.OK)
	@ResponseBody
	@PatchMapping("/{idActe}/double-numerique/integrer-double-numerique")
	public ResponseEntity<Result<String>> integrerActeDoubleNumerique(@RequestBody DocumentSigneDTO documentSigneDTO,
																	  @PathVariable UUID idActe,
																	  final HttpServletRequest request) {
		String idArobas = RecuperationHeaderUtils.getIdArobasFromHttpRequete(request);
		acteDoubleNumeriqueTraitement.integrerActeDoubleNumerique(idActe, idArobas, mapperDtoToDomain.map(documentSigneDTO));
		return new ResponseEntity<>(HttpStatus.OK);
	}
}





package fr.gouv.diplomatie.rece.etatcivil.dto.signature;


import jakarta.validation.Valid;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.io.Serial;
import java.io.Serializable;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class DocumentSigneDTO implements Serializable {

	@Serial
	private static final long serialVersionUID = 1L;

	private String documentPadesBase64;
	@Valid
	private SignatureIntegrationRecord signature;
	private ModeAuthentification modeAuthentification;

}



package fr.gouv.diplomatie.rece.etatcivil.dto.signature;

import jakarta.validation.constraints.NotBlank;

public record SignatureIntegrationRecord(
		@NotBlank(message = "L'issuerCertificat ne doit pas être null ou vide.") String issuerCertificat,
		@NotBlank(message = "L'entiteCertificat ne doit pas être null ou vide.") String entiteCertificat,
		String manufacturerIDCarte,
		String noSerieCarte,
		String noSerieCertificat,
		String algoSignature,
		String modelCarte,
		String notAfterCertificat,
		String notBeforeCertificat,
		String flagsCarte) {
}


package fr.gouv.diplomatie.rece.etatcivil.dto.signature;

public enum ModeAuthentification {
	AROBAS_MDP,
	AROBAS_MDP_TOTP,
	AROBAS_MDP_FIDO2
}
 import { ETATCIVIL_API } from "@api/ApiDisponibles";
import { TModeAuthentification } from "@model/agent/types";
import { TConfigurationApi } from "@model/api/Api";
import { IInformationsCarte } from "../../../../utils/Signature";

const URI = "/acte/:idActe/double-numerique/integrer-double-numerique";

interface IBody {
  documentPadesBase64: string;
  signature: IInformationsCarte;
  modeAuthentification: TModeAuthentification;
}

package fr.gouv.diplomatie.rece.etatcivil.application.services;

import fr.gouv.diplomatie.rece.etatcivil.application.ports.in.ActeDoubleNumeriqueTraitement;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.in.PreuveSignatureActeTraitement;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.in.ProjetActeEtabliTraitement;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.out.CompositionPort;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.out.UpdateActePort;
import fr.gouv.diplomatie.rece.etatcivil.application.ports.out.UpdateMentionPort;
import fr.gouv.diplomatie.rece.etatcivil.application.services.rules.acteetextrait.etabli.naissance.RegleFormatageTexteActeEtExtraitEtabliNaissance;
import fr.gouv.diplomatie.rece.etatcivil.application.services.utils.ActeElectroniqueUtils;
import fr.gouv.diplomatie.rece.etatcivil.application.services.utils.ActeElectroniqueValidator;
import fr.gouv.diplomatie.rece.etatcivil.application.services.utils.AnalyseMarginaleUtils;
import fr.gouv.diplomatie.rece.etatcivil.application.services.utils.DateUtils;
import fr.gouv.diplomatie.rece.etatcivil.domain.enums.TypeDocumentComposition;
import fr.gouv.diplomatie.rece.etatcivil.domain.habilitation.Utilisateur;
import fr.gouv.diplomatie.rece.etatcivil.domain.repertoirecivil.acte.Acte;
import fr.gouv.diplomatie.rece.etatcivil.domain.repertoirecivil.acte.ActeTexteJson;
import fr.gouv.diplomatie.rece.etatcivil.domain.repertoirecivil.mention.Mention;
import fr.gouv.diplomatie.rece.etatcivil.domain.repertoirecivil.signature.DocumentSigne;
import fr.gouv.diplomatie.rece.etatcivil.domain.repertoirecivil.signature.Signature;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections.CollectionUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.Base64;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import static org.apache.commons.lang3.StringUtils.SPACE;
import static org.apache.commons.lang3.StringUtils.isNotBlank;

@Service
@RequiredArgsConstructor
@Slf4j
public class ActeDoubleNumeriqueService implements ActeDoubleNumeriqueTraitement {

	private static final String POINT = ".";

	private final CompositionPort compositionPort;
	private final UpdateActePort updateActePort;
	private final UpdateMentionPort updateMentionPort;
	private final PreuveSignatureActeTraitement preuveSignatureActeTraitement;
	private final ProjetActeEtabliTraitement projetActeEtabliTraitement;
	private final ActeElectroniqueUtils acteElectroniqueUtils;
	private final ActeElectroniqueValidator acteElectroniqueValidator;


	@Override
	@Transactional
	public String composerActeDoubleNumerique(UUID idActe, Signature signature, String idArobas) {

		ActeElectroniqueValidator.ActeElectroniqueContext context = acteElectroniqueValidator.validerContexteActeDoubleNumerique(idActe, idArobas);

		acteElectroniqueValidator.validerFluxCompletActeDoubleNumerique(context.acte(), context.utilisateur());

		String numeroActe = acteElectroniqueUtils.genererNumeroActeElectroniqueFormatte(context.acte(), context.utilisateur());

		context.acte().setNumeroActeElectronique(numeroActe);

		traiterMentionFormuleIntegration(context.acte());

		valoriserMentionsActe(context.acte(), context.utilisateur(), signature);

		return genererPdfActeEnBase64(context.acte());
	}

	@Override
	@Transactional
	public void integrerActeDoubleNumerique(UUID idActe, String idArobas, DocumentSigne documentSigne) {
		acteElectroniqueValidator.verifierDisponibiliteSignatureElectronique();
		ActeElectroniqueValidator.ActeElectroniqueContext context = acteElectroniqueValidator.validerContexteActeDoubleNumerique(idActe, idArobas);
		projetActeEtabliTraitement.integrerActeSigne(context.acte(), context.utilisateur(), documentSigne);
	}

	private String genererPdfActeEnBase64(Acte acte) {
		ActeTexteJson acteTexteJson = construireActeTexteJson(acte);
		updateActePort.enregistrerProjetActe(acte);

		byte[] actePdf = compositionPort.composeDocumentsPdf(acteTexteJson, TypeDocumentComposition.ACTE_TEXTE);
		preuveSignatureActeTraitement.enregistrerAvantSignature(acte.getId(), actePdf);
		return Base64.getEncoder().encodeToString(actePdf);
	}

	private void traiterMentionFormuleIntegration(Acte acte) {
		if (acte.getMentions() == null || acte.getMentions().isEmpty()) {
			return;
		}

		acte.getMentions().stream()
			.filter(Mention::estMentionFormuleIntegration)
			.findFirst()
			.ifPresent(mention -> ajouterReferenceActeDansMention(mention, acte.getReferenceActeElectronique()));
	}

	private void ajouterReferenceActeDansMention(Mention mention, String referenceActe) {
		if (mention.getTextes() == null || !isNotBlank(mention.getTextes().getTexteMention())) {
			return;
		}

		String texteActuel = mention.getTextes().getTexteMention().trim();
		String texteSansPointFinal = texteActuel.endsWith(POINT) ? texteActuel.substring(0, texteActuel.length() - 1) : texteActuel;
		String texteModifie = texteSansPointFinal + SPACE + referenceActe + POINT;

		mention.getTextes().setTexteMention(texteModifie);
	}


	private ActeTexteJson construireActeTexteJson(Acte acte) {
		ActeTexteJson.ActeTexteJsonBuilder builder = ActeTexteJson.builder()
																  .referenceActe(acte.getReferenceActeElectronique())
																  .referenceRegistrePapier(acte.getReferenceRegistre())
																  .natureActe(acte.getNatureActeTexte())
																  .titulaires(extraireTitulairesActe(acte));

		if (acte.getCorpsTexte() != null) {
			builder.texteCorpsActe(acte.getCorpsTexte().getTexte());
		}
		ajouterMentions(builder, acte);

		return builder.build();
	}

	private String extraireTitulairesActe(Acte acte) {
		return AnalyseMarginaleUtils.formatAnalyseMarginaleActeTranscrit(
				acte.getAnalyseMarginales().iterator().next()
		);
	}

	private void ajouterMentions(ActeTexteJson.ActeTexteJsonBuilder builder, Acte acte) {
		if (CollectionUtils.isEmpty(acte.getMentions())) {
			return;
		}

		Set<Mention> mentionsValides = acte.getMentions().stream()
										   .filter(Mention::estMentionValide)
										   .collect(Collectors.toSet());
		if (!mentionsValides.isEmpty()) {
			String mentionsFormatees = RegleFormatageTexteActeEtExtraitEtabliNaissance
					.ecritLesMentionsDansLOrdre
					.apply(mentionsValides);
			builder.mentions(mentionsFormatees);
		}
	}

	private void valoriserMentionsActe(Acte acte, Utilisateur utilisateur, Signature signature) {
		String villeApposition = utilisateur.getService().getAdresseService().getVille();
		LocalDate dateApposition = DateUtils.getDateActuelleDuService(utilisateur);
		String texteApposition = RegleFormatageTexteActeEtExtraitEtabliNaissance.formatTexteAppositionMention(villeApposition, dateApposition);

		acte.getMentions().stream()
			.filter(Mention::estMentionBrouillon)
			.forEach(mention -> valoriserMention(mention, acte.getId(), villeApposition, dateApposition, texteApposition, signature));
	}

	private void valoriserMention(Mention mention, UUID idActe, String ville, LocalDate date, String texteApposition, Signature signature) {
		mention.setVilleApposition(ville);
		mention.setDateApposition(date);

		if (mention.getTextes() != null) {
			mention.getTextes().setTexteApposition(texteApposition);
		}

		if (!mention.estMentionFormuleIntegration() && mention.getAutoriteEtatCivil() != null) {
			mention.getAutoriteEtatCivil().setNomOEC(signature.getNomOEC());
			mention.getAutoriteEtatCivil().setPrenomOEC(signature.getPrenomOEC());

			String texteOEC = RegleFormatageTexteActeEtExtraitEtabliNaissance.formatTexteOecMention(mention.getAutoriteEtatCivil());
			mention.getTextes().setTexteOEC(texteOEC);
		}

		updateMentionPort.addMention(mention, idActe);
	}

}

this is the frontend i have now, 

export const CONFIG_PATCH_INTEGRER_ACTE_DOUBLE_NUMERIQUE: TConfigurationApi<typeof URI, IBody> = {
  api: ETATCIVIL_API,
  methode: "PATCH",
  uri: URI,
  avecAxios: true
};

import { Droit } from "@model/agent/enum/Droit";
import { useContext, useMemo, useState } from "react";
import { ECleOngletsMiseAJour, EditionMiseAJourContext } from "../../../../contexts/EditionMiseAJourContextProvider";
import { RECEContextData } from "../../../../contexts/RECEContextProvider";
import AfficherMessage from "../../../../utils/AfficherMessage";
import Bouton from "../../../commun/bouton/Bouton";
import ConteneurModale from "../../../commun/conteneurs/modale/ConteneurModale";
import SignatureDocument from "../../../commun/signature/SignatureDocument";

interface IBoutonTerminerEtSignerProps {
  saisieMentionEnCours: boolean;
  acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits: boolean;
}

const BoutonTerminerEtSigner: React.FC<IBoutonTerminerEtSignerProps> = ({
  saisieMentionEnCours,
  acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits
}) => {
  const { utilisateurConnecte } = useContext(RECEContextData);
  const { idActe, idRequete, miseAJourEffectuee } = useContext(EditionMiseAJourContext.Valeurs);
  const { setEstActeSigne, desactiverBlocker, changerOnglet } = useContext(EditionMiseAJourContext.Actions);
  const aDroitSigner = useMemo<boolean>(
    () => utilisateurConnecte.estHabilitePour({ tousLesDroits: [Droit.SIGNER_MENTION, Droit.METTRE_A_JOUR_ACTE] }),
    [utilisateurConnecte]
  );
  const [modaleOuverte, setModaleOuverte] = useState<boolean>(false);

  if (!aDroitSigner) return <></>;

  return (
    <>
      <Bouton
        type="button"
        title="Terminer et signer"
        disabled={saisieMentionEnCours || !miseAJourEffectuee}
        onClick={() => setModaleOuverte(true)}
      >
        {"Terminer et signer"}
      </Bouton>

      {modaleOuverte && (
        <ConteneurModale>
          <div className="border-3 w-[34rem] max-w-full rounded-xl border-solid border-bleu-sombre bg-blanc p-5">
            <h2 className="m-0 mb-4 text-center font-medium text-bleu-sombre">{"Signature des mentions"}</h2>
            <SignatureDocument
              typeSignature={acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits ? "DOUBLE_NUMERIQUE" : "MISE_A_JOUR"}
              idActe={idActe}
              idRequete={idRequete}
              apresSignature={(succes: boolean) => {
                setModaleOuverte(false);
                if (!succes) return;

                changerOnglet(ECleOngletsMiseAJour.ACTE, null);
                setEstActeSigne(true);
                AfficherMessage.succes("L'acte a été mis à jour avec succès.", { fermetureAuto: true });
                desactiverBlocker();
              }}
            />
          </div>
        </ConteneurModale>
      )}
    </>
  );
};

export default BoutonTerminerEtSigner;

import { CONFIG_PATCH_COMPOSER_DOCUMENT_FINAL_DOUBLE_NUMERIQUE } from "@api/configurations/etatCivil/acte/PatchComposerDocumentFinalDoubleNumeriqueConfigApi";
import { CONFIG_PATCH_COMPOSER_DOCUMENT_MENTIONS_ULTERIEURES } from "@api/configurations/etatCivil/acte/PatchComposerDocumentMentionsUlterieuresConfigApi";
import { CONFIG_PATCH_INTEGRER_ACTE_DOUBLE_NUMERIQUE } from "@api/configurations/etatCivil/acte/PatchIntegrerActeDoubleNumeriqueConfigApi";
import { CONFIG_PATCH_INTEGRER_DOCUMENT_MENTION_SIGNER } from "@api/configurations/etatCivil/acte/PatchIntegrerDocumentMentionSigneConfigApi";
import { CONFIG_PATCH_COMPOSER_DOCUMENT_FINAL_PROJET_ACTE_ETABLI } from "@api/configurations/etatCivil/projetActe/PatchComposerDocumentFinalProjetActeEtabliConfigApi";
import { CONFIG_PATCH_COMPOSER_DOCUMENT_FINAL_PROJET_ACTE_TRANSCRIT } from "@api/configurations/etatCivil/projetActe/PatchComposerDocumentFinalProjetActeTranscritConfigApi";
import { CONFIG_PATCH_INTEGRER_DOCUMENT_FINAL_PROJET_ACTE_ETABLI } from "@api/configurations/etatCivil/projetActe/PatchIntegrerDocumentFinalProjetActeEtabliConfigApi";
import { CONFIG_PATCH_INTEGRER_DOCUMENT_FINAL_PROJET_ACTE_TRANSCRIT } from "@api/configurations/etatCivil/projetActe/PatchIntegrerDocumentFinalProjetActeTranscritConfigApi";
import { CONFIG_PATCH_STATUT_REQUETE_CREATION } from "@api/configurations/requete/creation/PatchStatutRequeteCreationConfigApi";
import { CONFIG_PATCH_STATUT_REQUETE_ETABLI_APRES_SIGNATURE } from "@api/configurations/requete/creation/PatchStatutRequeteEtabliApresSignatureConfigApi";
import { CONFIG_PATCH_STATUT_REQUETE_MISE_A_JOUR } from "@api/configurations/requete/miseAJour/PatchStatutRequeteMiseAjourConfigApi";
import { TErreurApi } from "@model/api/Api";
import { StatutRequete } from "@model/requete/enum/StatutRequete";
import { TypePopinSignature } from "@model/signature/ITypePopinSignature";
import CircularProgress from "@mui/material/CircularProgress";
import { useContext, useEffect, useMemo, useState } from "react";
import { RECEContextData } from "../../../contexts/RECEContextProvider";
import useFetchApi from "../../../hooks/api/FetchApiHook";
import Signature, { CODE_PIN_INVALIDE, IInformationsCarte } from "../../../utils/Signature";
import Bouton from "../bouton/Bouton";
import CodePinForm from "./CodePinForm";
import InformationsDeveloppeur from "./InformationsDeveloppeur";

type TStatutSignature =
  | "attente-pin"
  | "recuperation-informations"
  | "composition-document"
  | "signature-document"
  | "enregistrement-document"
  | "termine";

type TTypeSignature = "MISE_A_JOUR" | "ETABLI" | "TRANSCRIT" | "DOUBLE_NUMERIQUE";

interface IDonneesSignature {
  statut: TStatutSignature;
  codePin: string | null;
  erreurPin: boolean;
  erreur: string | null;
  informationsCarte: IInformationsCarte | null;
  documentASigner: string | null;
  documentSigne: string | null;
}

interface ISignatureCommunProps {
  idActe: string;
  idRequete: string;
  apresSignature: (succes: boolean) => void;
}

interface ISignatureMiseAJourProps extends ISignatureCommunProps {
  typeSignature: TTypeSignature;
  idSuivi?: never;
}

interface ISignatureDoubleNumeriqueProps extends ISignatureCommunProps {
  typeSignature: "DOUBLE_NUMERIQUE";
  idSuivi?: never;
}

interface ISignatureEtablissementProps extends ISignatureCommunProps {
  typeSignature: TTypeSignature;
  idSuivi: string;
}

interface ISignatureTranscriptionProps extends ISignatureCommunProps {
  typeSignature: TTypeSignature;
  idSuivi?: never;
}

const DONNEES_SIGNATURE_DEFAUT: IDonneesSignature = {
  statut: "attente-pin",
  codePin: null,
  erreurPin: false,
  erreur: null,
  informationsCarte: null,
  documentASigner: null,
  documentSigne: null
};

const AVANCEMENT: { [EtatAvancement in Exclude<TStatutSignature, "attente-pin" | "termine">]: { niveau: number; message: string } } = {
  "recuperation-informations": { niveau: 0, message: "Récupération des informations de signature..." },
  "composition-document": { niveau: 33, message: "Génération du document à signer..." },
  "signature-document": { niveau: 66, message: "Signature du document..." },
  "enregistrement-document": { niveau: 100, message: "Enregistrement du document signé..." }
};

/* NOSONAR */ const SignatureDocument: React.FC<
  ISignatureMiseAJourProps | ISignatureEtablissementProps | ISignatureTranscriptionProps | ISignatureDoubleNumeriqueProps
> = ({ idActe, idRequete, apresSignature, typeSignature, idSuivi = null }) => {
  const { utilisateurConnecte } = useContext(RECEContextData);

  const signature = useMemo(
    () => ({
      estMiseAJour: typeSignature === "MISE_A_JOUR" || typeSignature === "DOUBLE_NUMERIQUE",
      messageInformation: (() => {
        switch (typeSignature) {
          case "MISE_A_JOUR":
            return TypePopinSignature.getTextePopinSignatureMentions() ?? "";
          case "DOUBLE_NUMERIQUE":
            return TypePopinSignature.getTextePopinSignatureMentions() ?? "";
          case "ETABLI":
            return TypePopinSignature.getTextePopinSignatureActe() ?? "";
          case "TRANSCRIT":
            return TypePopinSignature.getTextePopinSignatureActeTranscrit() ?? "";
          default:
            return "";
        }
      })()
    }),
    [typeSignature]
  );

  const { appelApi: appelComposerMentions } = useFetchApi(CONFIG_PATCH_COMPOSER_DOCUMENT_MENTIONS_ULTERIEURES);
  const { appelApi: appelIntegrerMentions } = useFetchApi(CONFIG_PATCH_INTEGRER_DOCUMENT_MENTION_SIGNER);
  const { appelApi: appelModifierStatutRequeteMiseAJour } = useFetchApi(CONFIG_PATCH_STATUT_REQUETE_MISE_A_JOUR, true);

  const { appelApi: appelComposerDoubleNumerique } = useFetchApi(CONFIG_PATCH_COMPOSER_DOCUMENT_FINAL_DOUBLE_NUMERIQUE);
  const { appelApi: appelIntegrerActeDoubleNumerique } = useFetchApi(CONFIG_PATCH_INTEGRER_ACTE_DOUBLE_NUMERIQUE);

  const { appelApi: appelComposerProjetActeEtabli } = useFetchApi(CONFIG_PATCH_COMPOSER_DOCUMENT_FINAL_PROJET_ACTE_ETABLI);
  const { appelApi: appelIntegrerProjetActeEtabli } = useFetchApi(CONFIG_PATCH_INTEGRER_DOCUMENT_FINAL_PROJET_ACTE_ETABLI);
  const { appelApi: appelModifierStatutRequeteEtabli } = useFetchApi(CONFIG_PATCH_STATUT_REQUETE_ETABLI_APRES_SIGNATURE);

  const { appelApi: appelComposerProjetActeTranscrit } = useFetchApi(CONFIG_PATCH_COMPOSER_DOCUMENT_FINAL_PROJET_ACTE_TRANSCRIT);
  const { appelApi: appelIntegrerProjetActeTranscrit } = useFetchApi(CONFIG_PATCH_INTEGRER_DOCUMENT_FINAL_PROJET_ACTE_TRANSCRIT);
  const { appelApi: appelModifierStatutRequeteTranscrit } = useFetchApi(CONFIG_PATCH_STATUT_REQUETE_CREATION, true);

  const [donneesSignature, setDonneesSignature] = useState<IDonneesSignature>({ ...DONNEES_SIGNATURE_DEFAUT });

  /*   const composerDoubleNumeriqueEtMentions: typeof appelComposerDoubleNumerique = options => {
    const { parametres, apresSucces, apresErreur, finalement, ...autres } = options;

    appelComposerMentions({
      parametres: parametres as Parameters<typeof appelComposerMentions>[0]["parametres"],
      apresSucces: () => {
        appelComposerDoubleNumerique({
          parametres,
          apresSucces,
          apresErreur,
          finalement,
          ...autres
        });
      },
      apresErreur,
      finalement,
      ...autres
    });
  };
 */
  const configurationSignature = {
    MISE_A_JOUR: {
      composer: appelComposerMentions,
      enregistrer: appelIntegrerMentions,
      modifierStatut: appelModifierStatutRequeteMiseAJour
    },
    DOUBLE_NUMERIQUE: {
      composer: appelComposerDoubleNumerique,
      enregistrer: appelIntegrerActeDoubleNumerique,
      modifierStatut: appelModifierStatutRequeteMiseAJour
    },
    ETABLI: {
      composer: appelComposerProjetActeEtabli,
      enregistrer: appelIntegrerProjetActeEtabli,
      modifierStatut: appelModifierStatutRequeteEtabli
    },
    TRANSCRIT: {
      composer: appelComposerProjetActeTranscrit,
      enregistrer: appelIntegrerProjetActeTranscrit,
      modifierStatut: appelModifierStatutRequeteTranscrit
    }
  } as const satisfies Record<TTypeSignature, unknown>;

  const recuperationInformations = () => {
    console.info("[SIGNATURE] Récupération des informations de la carte ...");
    donneesSignature.codePin &&
      Signature.recupererInformationsCarte({
        parametres: {
          idActe: idActe,
          codePin: donneesSignature.codePin,
          idAgent: utilisateurConnecte.id,
          prenomNomAgent: utilisateurConnecte.prenomNom,
          estMiseAJour: signature.estMiseAJour
        },
        apresSucces: informations => {
          console.info("[SIGNATURE] Récupération des informations de la carte effectuée");
          setDonneesSignature(prec => ({
            ...prec,
            informationsCarte: informations,
            statut: "composition-document"
          }));
        },
        apresErreur: erreur => {
          console.error(
            `[SIGNATURE] Erreur récupération des informations de la carte : ${erreur.code} - ${erreur.libelle} - ${erreur?.detail ?? "AUCUN DETAIL"}`
          );
          setDonneesSignature(prec => ({
            ...prec,
            erreur: erreur.libelle,
            erreurPin: erreur.code === CODE_PIN_INVALIDE,
            statut: erreur.code === CODE_PIN_INVALIDE ? "attente-pin" : "termine"
          }));
        }
      });
  };

  const compositionDocument = () => {
    console.info("[SIGNATURE] Composition du document à signer ...");

    if (!donneesSignature.informationsCarte) return;

    const config = configurationSignature[typeSignature];

    config.composer({
      parametres: {
        path: { idActe: idActe },
        body: {
          issuerCertificat: donneesSignature.informationsCarte.issuerCertificat,
          entiteCertificat: donneesSignature.informationsCarte.entiteCertificat
        }
      },
      apresSucces: documentASigner => {
        console.info("[SIGNATURE] Composition du document à signer effectuée");
        setDonneesSignature(prec => ({
          ...prec,
          documentASigner: documentASigner,
          statut: "signature-document"
        }));
      },
      apresErreur: erreurs => {
        const messageErreurServeur = ["FCT_16108", "TECH_16021"].includes(erreurs[0]?.code) ? erreurs[0]?.message : null;
        const messageErreurDefaut = "Erreur lors de la composition du document à signer";
        console.error(
          `[SIGNATURE] ${messageErreurDefaut} : ${erreurs[0]?.code ?? "CODE_INCONNU"} - ${erreurs[0]?.message ?? "Erreur inconnue"}`
        );

        setDonneesSignature(prec => ({
          ...prec,
          erreur: messageErreurServeur ?? messageErreurDefaut,
          statut: "termine"
        }));
      }
    });
  };

  const signatureDocument = () => {
    console.info(`[SIGNATURE] Signature du document ...`);
    donneesSignature.codePin &&
      donneesSignature.documentASigner &&
      Signature.signerDocument({
        parametres: {
          idActe: idActe,
          idAgent: utilisateurConnecte.id,
          document: donneesSignature.documentASigner,
          codePin: donneesSignature.codePin,
          estMiseAJour: signature.estMiseAJour
        },
        apresReponse: reponse => {
          const erreur = reponse.erreur?.libelle ?? null;
          const documentSigne = reponse.document ?? null;
          const messageErreur = !erreur && !documentSigne ? "Erreur inattendue" : erreur;
          messageErreur
            ? console.error(
                `[SIGNATURE] Erreur lors de la signature du document : ${reponse.erreur?.code ?? "CODE_INCONNU"} - ${messageErreur} - ${reponse.erreur?.detail ?? "AUCUN DETAIL"}`
              )
            : console.info(`[SIGNATURE] Signature du document effectuée`);

          setDonneesSignature(prec => ({
            ...prec,
            documentASigner: null,
            documentSigne: documentSigne,
            erreur: messageErreur,
            informationsCarte: reponse.infosSignature ?? null,
            statut: documentSigne ? "enregistrement-document" : "termine"
          }));
        }
      });
  };

  const enregistrementDocument = () => {
    console.info("[SIGNATURE] Enregistrement du document signé ...");

    if (!donneesSignature.documentSigne || !donneesSignature.informationsCarte) return;

    const config = configurationSignature[typeSignature];

    config.enregistrer({
      parametres: {
        path: { idActe: idActe },
        body: {
          documentPadesBase64: donneesSignature.documentSigne,
          signature: donneesSignature.informationsCarte,
          modeAuthentification: "AROBAS_MDP"
        }
      },
      apresSucces: () => {
        console.info("[SIGNATURE] Enregistrement du document signé effectué");
        console.info("[SIGNATURE] Modification du statut de la requête ...");

        const apresModificationStatut = {
          apresSucces: () => console.info("[SIGNATURE] Modification du statut de la requête effectué"),
          apresErreur: (erreurs: TErreurApi[]) =>
            console.error(
              `[SIGNATURE] Erreur lors de la modification du statut de la requête : ${erreurs[0]?.code ?? "CODE_INCONNU"} - ${erreurs[0]?.message ?? "Erreur inconnue"}`
            ),
          finalement: () =>
            setDonneesSignature(prec => ({
              ...prec,
              statut: "termine"
            }))
        };

        switch (typeSignature) {
          case "MISE_A_JOUR":
            appelModifierStatutRequeteMiseAJour({
              parametres: { path: { idRequete: idRequete, statut: StatutRequete.TRAITEE_MIS_A_JOUR.nom } },
              ...apresModificationStatut
            });

            return;

          case "ETABLI":
            if (idSuivi?.length) {
              appelModifierStatutRequeteEtabli({
                parametres: { path: { idRequete: idRequete, idSuiviDossier: idSuivi ?? "" } },
                ...apresModificationStatut
              });
            } else {
              console.error("[SIGNATURE] Erreur lors de la modification du statut de la requête : ID Suivi inconnu");
              setDonneesSignature(prec => ({
                ...prec,
                statut: "termine"
              }));
            }

            return;

          case "TRANSCRIT":
            appelModifierStatutRequeteTranscrit({
              parametres: { path: { idRequete: idRequete }, query: { statut: StatutRequete.getKey(StatutRequete.TRAITE) } },
              ...apresModificationStatut,
              apresSucces: () => {
                apresSignature(true);
              }
            });

            return;

          default:
            console.error(`[SIGNATURE] Type de signature inconnu : ${typeSignature}`);
            setDonneesSignature(prec => ({
              ...prec,
              statut: "termine"
            }));
            return;
        }
      },
      apresErreur: erreurs => {
        const messageErreurServeur = ["FCT_16108", "TECH_16021"].includes(erreurs[0]?.code) ? erreurs[0]?.message : null;
        const messageErreurDefaut = `Erreur lors de l'enregistrement ${signature.estMiseAJour ? "des mentions signées" : "de l'acte signé"} `;
        console.error(
          `[SIGNATURE] ${messageErreurDefaut} : ${erreurs[0]?.code ?? "CODE_INCONNU"} - ${erreurs[0]?.message ?? "Erreur inconnue"}`
        );

        setDonneesSignature(prec => ({
          ...prec,
          erreur: messageErreurServeur ?? messageErreurDefaut,
          statut: "termine"
        }));
      }
    });
  };

  useEffect(() => {
    switch (donneesSignature.statut) {
      case "recuperation-informations":
        recuperationInformations();
        break;

      case "composition-document":
        compositionDocument();
        break;

      case "signature-document":
        signatureDocument();
        break;

      case "enregistrement-document":
        enregistrementDocument();
        break;
      default:
        break;
    }
  }, [donneesSignature.statut]);

  switch (donneesSignature.statut) {
    case "attente-pin":
      return (
        <>
          {signature.messageInformation && <div className="mb-4 text-start">{signature.messageInformation}</div>}

          <InformationsDeveloppeur />

          <CodePinForm
            onSubmit={codePin =>
              setDonneesSignature(prec => ({
                ...prec,
                codePin: codePin,
                erreurPin: false,
                statut: "recuperation-informations"
              }))
            }
            fermerModale={() => {
              setDonneesSignature({ ...DONNEES_SIGNATURE_DEFAUT });
              apresSignature(false);
            }}
            erreurPin={donneesSignature.erreurPin}
          />
        </>
      );

    case "recuperation-informations":
    case "composition-document":
    case "signature-document":
    case "enregistrement-document":
      return (
        <div>
          <div className="mt-1 h-2 w-full overflow-hidden rounded-full border border-solid border-gris">
            <div
              className="h-full bg-bleu"
              style={{
                width: `${AVANCEMENT[donneesSignature.statut].niveau}%`,
                transition: "width .4s ease"
              }}
            ></div>
          </div>

          <div className="text-center">{AVANCEMENT[donneesSignature.statut].message}</div>

          <div className="pt-4 text-center">
            <CircularProgress size={30} />
          </div>
        </div>
      );

    case "termine": {
      const estTypeSignatureMajOuEtabli = ["ETABLI", "MISE_A_JOUR"].includes(typeSignature);
      return (
        <div className="text-center">
          {donneesSignature.erreur && (
            <>
              <div className="font-bold text-rouge">{"⚠ Impossible d'effectuer la signature :"}</div>
              <div className="text-rouge">{donneesSignature.erreur}</div>
            </>
          )}

          {!donneesSignature.erreur && estTypeSignatureMajOuEtabli && <div>{"Signature des mentions effectuée."}</div>}

          {estTypeSignatureMajOuEtabli && (
            <Bouton
              className="mt-6"
              title="Fermer"
              styleBouton="principal"
              onClick={() => {
                setDonneesSignature({ ...DONNEES_SIGNATURE_DEFAUT });
                apresSignature(!donneesSignature.erreur);
              }}
            >
              {"Fermer"}
            </Bouton>
          )}

          {donneesSignature.erreur && !estTypeSignatureMajOuEtabli && (
            <div className="mt-6">
              <Bouton
                title="Réessayer"
                styleBouton="principal"
                onClick={() => {
                  setDonneesSignature({ ...DONNEES_SIGNATURE_DEFAUT });
                }}
              >
                {"Réessayer"}
              </Bouton>
            </div>
          )}
        </div>
      );
    }
    default:
      return <></>;
  }
};

export default SignatureDocument;


import { CONFIG_GET_RESUME_ACTE } from "@api/configurations/etatCivil/acte/GetResumeActeConfigApi";
import CONFIG_GET_FORMULE_INTEGRATION_RECE, {
  IFormuleIntegrationDto
} from "@api/configurations/etatCivil/nomenclature/GetFormuleIntegrationRECEApi";
import { CONFIG_PUT_ANALYSE_MARGINALE_ET_MENTIONS } from "@api/configurations/etatCivil/PutAnalyseMarginaleEtMentionsConfigApi";
import { CONFIG_PUT_MISE_A_JOUR_ANALYSE_MARGINALE } from "@api/configurations/etatCivil/PutMiseAJourAnalyseMarginaleConfigApi";
import { Droit } from "@model/agent/enum/Droit";
import { TErreurApi } from "@model/api/Api";
import { FicheActe } from "@model/etatcivil/acte/FicheActe";
import AnalyseMarginaleForm from "@model/form/AnalyseMarginale/AnalyseMarginaleForm";
import { TObjetFormulaire } from "@model/form/commun/ObjetFormulaire";
import { TPrenomsForm } from "@model/form/commun/PrenomsForm";
import MiseAJourForm from "@model/form/miseAJour/MiseAJourForm";
import { estActeEligibleFormuleDIntegration } from "@pages/fiche/FichePage";
import { Formik } from "formik";
import { useContext, useEffect, useMemo, useState } from "react";
import { Form } from "react-router";
import { ECleOngletsMiseAJour, EditionMiseAJourContext } from "../../../contexts/EditionMiseAJourContextProvider";
import { RECEContextData } from "../../../contexts/RECEContextProvider";
import useFetchApi from "../../../hooks/api/FetchApiHook";
import AfficherMessage from "../../../utils/AfficherMessage";
import Bouton from "../../commun/bouton/Bouton";
import { ConteneurBoutonBasDePage } from "../../commun/bouton/conteneurBoutonBasDePage/ConteneurBoutonBasDePage";
import PageChargeur from "../../commun/chargeurs/PageChargeur";
import ConteneurAvecBordure from "../../commun/conteneurs/formulaire/ConteneurAvecBordure";
import ConteneurModale from "../../commun/conteneurs/modale/ConteneurModale";
import OngletsBouton from "../../commun/onglets/OngletsBouton";
import OngletsContenu from "../../commun/onglets/OngletsContenu";
import BoutonTerminerEtSigner from "./formulaires/BoutonTerminerEtSigner";
import BoutonValiderEtTerminer from "./formulaires/BoutonValiderEtTerminer";
import MentionForm, { ITitulaireMention } from "./formulaires/MentionForm";
import AnalyseMarginaleFormulaire from "./formulaires/mentions/AnalyseMarginaleFormulaire/AnalyseMarginaleFormulaire";
import TableauMentions from "./formulaires/mentions/ListeMentionsFormulaire/TableauMentions";

interface IDonneesAideSaisie {
  champs: TObjetFormulaire;
  textesEdites: { [cle: string]: { edite: string; original: string } };
}

export interface IMentionMiseAJour {
  texte: string;
  idTypeMention: string;
  affecteAnalyseMarginale: boolean;
  donneesAideSaisie?: IDonneesAideSaisie;
}

export interface IMentionEnCours {
  index: number | null;
  mention: IMentionMiseAJour;
}

export interface IAnalyseMarginaleMiseAJour extends TObjetFormulaire {
  motif: string;
  titulaires: {
    nom: string;
    nomSecable: boolean;
    nomPartie1: string;
    nomPartie2: string;
    prenoms: TPrenomsForm;
  }[];
}

export interface IMiseAJourForm {
  mentions: IMentionMiseAJour[];
  analyseMarginale: IAnalyseMarginaleMiseAJour;
}

export interface IMiseAJourMentionsForm {
  mentions: IMentionMiseAJour[];
}

const PartieFormulaire: React.FC = () => {
  const { estMiseAJourAvecMentions, ongletsActifs, idActe, miseAJourEffectuee } = useContext(EditionMiseAJourContext.Valeurs);
  const { changerOnglet, activerOngletActeMisAJour, setComposerActeMisAJour } = useContext(EditionMiseAJourContext.Actions);

  const { appelApi: mettreAJourAnalyseMarginaleEtMentions, enAttenteDeReponseApi: enAttenteMiseAJourAnalyseMarginaleEtMention } =
    useFetchApi(CONFIG_PUT_ANALYSE_MARGINALE_ET_MENTIONS);
  const { appelApi: mettreAJourAnalyseMarginale, enAttenteDeReponseApi: enAttenteMiseAJourAnalyseMarginale } = useFetchApi(
    CONFIG_PUT_MISE_A_JOUR_ANALYSE_MARGINALE
  );
  const [afficherAnalyseMarginale, setAfficherAnalyseMarginale] = useState(!estMiseAJourAvecMentions);

  const [formulaireMentionEnCoursDeSaisie, setFormulaireMentionEnCoursDeSaisie] = useState<boolean>(false);

  const [afficherModaleAnalyseMarginale, setAfficherModaleAnalyseMarginale] = useState<boolean>(false);
  const [donneesAnalyseMarginale, setDonneesAnalyseMarginale] = useState<IAnalyseMarginaleMiseAJour | null>(null);
  const [analyseMarginaleModifiee, setAnalyseMarginaleModifiee] = useState<boolean>(false);
  const [mentionsDeLActe, setMentionsDeLActe] = useState<IMentionMiseAJour[]>([]);
  const [mentionsDuTableau, setMentionsDuTableau] = useState<IMentionMiseAJour[]>([]);
  const [mentionEnCoursDeSaisie, setMentionEnCoursDeSaisie] = useState<IMentionEnCours | null>(null);
  const [motif, setMotif] = useState<string | null>(null);

  const [acte, setActe] = useState<FicheActe | null>(null);
  const { appelApi: getResumeActe } = useFetchApi(CONFIG_GET_RESUME_ACTE, true);
  const { appelApi: getFormuleIntegrationRece } = useFetchApi(CONFIG_GET_FORMULE_INTEGRATION_RECE, true);
  const [valeursInitialesFormulaireAnalyseMarginale, setValeursInitialesFormulaireAnalyseMarginale] =
    useState<IAnalyseMarginaleMiseAJour | null>(null);
  const { utilisateurConnecte } = useContext(RECEContextData);

  const [formuleDIntegration, setFormuleDIntegration] = useState<IFormuleIntegrationDto | null>(null);

  const acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits = useMemo(() => {
    if (acte !== null) {
      return (
        estActeEligibleFormuleDIntegration(acte) &&
        utilisateurConnecte.estHabilitePour({ tousLesDroits: [Droit.METTRE_A_JOUR_ACTE, Droit.MISE_A_JOUR_CREER_DOUBLE_NUMERIQUE] })
      );
    }
    return false;
  }, [acte, utilisateurConnecte]);

  useEffect(() => {
    if (acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits && formuleDIntegration === null) {
      getFormuleIntegrationRece({
        parametres: {},
        apresSucces: formuleDIntegration => {
          setFormuleDIntegration(formuleDIntegration);
        },
        apresErreur: erreurs =>
          AfficherMessage.erreur("Une erreur est survenue lors de la récupération des informations de la formule d'intégration au RECE", {
            erreurs
          })
      });
    }
  }, [acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits]);

  useEffect(() => {
    if (estMiseAJourAvecMentions) {
      let mentions: IMentionMiseAJour[];
      const analyseMarginaleEstMiseAJour = afficherAnalyseMarginale && analyseMarginaleModifiee && donneesAnalyseMarginale !== null;

      // Mention saisie dans le formulaire de saisie
      if (mentionEnCoursDeSaisie?.mention) {
        // Mention modifiée
        if (typeof mentionEnCoursDeSaisie.index === "number") {
          if (mentionsDeLActe[mentionEnCoursDeSaisie.index] === mentionEnCoursDeSaisie.mention) return;

          mentions = mentionsDeLActe.map((mention, index) =>
            index === mentionEnCoursDeSaisie.index ? mentionEnCoursDeSaisie.mention : mention
          );

          // Mention ajoutée
        } else {
          mentions = [...mentionsDeLActe, mentionEnCoursDeSaisie.mention];
        }

        // Analyse marginale modifiée
      } else if (analyseMarginaleEstMiseAJour) {
        mentions = mentionsDeLActe;

        // Ordre des mentions modifié ou mention supprimée
      } else {
        mentions = mentionsDuTableau;
      }

      if (!mentions.length) return;

      mettreAJourAnalyseMarginaleEtMentions({
        parametres: {
          body: MiseAJourForm.versDto(
            idActe,
            [
              ...(formuleDIntegration !== null
                ? [
                    {
                      idTypeMention: formuleDIntegration.idTypeMention,
                      affecteAnalyseMarginale: formuleDIntegration.affecteAnalyseMarginale,
                      texte: formuleDIntegration.texteFormule
                    }
                  ]
                : []),
              ...mentions
            ],
            donneesAnalyseMarginale,
            analyseMarginaleEstMiseAJour
          )
        },
        apresSucces: () => {
          setMentionsDeLActe(mentions);
          activerMiseAJourActe();
          resetModificationMention();

          !analyseMarginaleEstMiseAJour &&
            setAfficherModaleAnalyseMarginale(mentions[mentionEnCoursDeSaisie?.index ?? mentions.length - 1].affecteAnalyseMarginale);
        },
        apresErreur: (erreurs: TErreurApi[]) => {
          const messageErreur = (() => {
            switch (true) {
              case Boolean(erreurs?.find(erreur => erreur.code === "FCT_16136")):
                return "Aucune modification de l'analyse marginale n'a été détectée";
              case Boolean(erreurs?.find(erreur => erreur.code === "FCT_160168")):
                return "La personne liée ne peut pas être le titulaire de l'acte";
              default:
                return "Impossible de mettre à jour l'acte";
            }
          })();

          AfficherMessage.erreur(messageErreur, { erreurs, fermetureAuto: true });
        }
      });
    }

    if (!estMiseAJourAvecMentions && donneesAnalyseMarginale !== null) {
      mettreAJourAnalyseMarginale({
        parametres: {
          path: { idActe: idActe },
          body: AnalyseMarginaleForm.versDto(donneesAnalyseMarginale)
        },
        apresSucces: () => {
          activerOngletActeMisAJour();
          setComposerActeMisAJour(true);
          changerOnglet(ECleOngletsMiseAJour.ACTE_MIS_A_JOUR, null);
        },
        apresErreur: (erreurs: TErreurApi[]) => {
          const messageErreur = erreurs.find(erreur => erreur.code === "FCT_16136")
            ? "Aucune modification de l'analyse marginale n'a été détectée"
            : "Impossible de mettre à jour l'analyse marginale";

          AfficherMessage.erreur(messageErreur, { erreurs, fermetureAuto: true });
        }
      });
    }
  }, [donneesAnalyseMarginale, mentionEnCoursDeSaisie, mentionsDuTableau]);

  useEffect(() => {
    getResumeActe({
      parametres: {
        path: { idActe },
        query: { remplaceIdentiteTitulaireParIdentiteTitulaireAM: true }
      },
      apresSucces: acteDto => {
        setActe(FicheActe.depuisDto(acteDto));
      },
      apresErreur: erreurs =>
        AfficherMessage.erreur("Une erreur est survenue lors de la récupération des informations de l'acte", { erreurs })
    });
  }, []);

  useEffect(() => {
    if (!acte) return;

    setValeursInitialesFormulaireAnalyseMarginale(
      AnalyseMarginaleForm.genererValeursDefautFormulaire(acte.getTitulairesPourAnalyseMarginale(), motif)
    );
  }, [motif, acte]);

  const resetModificationMention = () => {
    setMentionEnCoursDeSaisie(mention => (mention ? null : mention));
    setMentionsDuTableau(mentions => (mentions.length > 0 ? [] : mentions));
    setFormulaireMentionEnCoursDeSaisie(false);
  };

  const activerMiseAJourActe = () => {
    activerOngletActeMisAJour();
    setComposerActeMisAJour(true);
    changerOnglet(ECleOngletsMiseAJour.ACTE_MIS_A_JOUR, null);
  };

  const titulairesMention: ITitulaireMention[] = useMemo(() => {
    if (!acte) return [];

    return [...Array(acte.getNombreTitulairesSelonNature()).keys()].map(index => {
      return {
        nom: acte?.titulaires?.[index].nom ?? "",
        nomPartie1: acte?.titulaires?.[index].nomPartie1 ?? "",
        nomPartie2: acte?.titulaires?.[index].nomPartie2 ?? "",
        nomSecable: Boolean(acte?.titulaires?.[index].nomPartie1 && acte?.titulaires?.[index].nomPartie2),
        prenoms: acte?.titulaires?.[index].prenoms ?? [],
        sexe: acte?.titulaires?.[index].sexe ?? null
      };
    });
  }, [acte]);

  return (
    <>
      {(enAttenteMiseAJourAnalyseMarginale || enAttenteMiseAJourAnalyseMarginaleEtMention) && <PageChargeur />}
      <div className="w-1/2">
        <OngletsBouton<ECleOngletsMiseAJour>
          onglets={[
            ...(estMiseAJourAvecMentions
              ? [
                  {
                    cle: ECleOngletsMiseAJour.MENTIONS,
                    libelle: "Mentions"
                  }
                ]
              : []),

            ...(afficherAnalyseMarginale
              ? [
                  {
                    cle: ECleOngletsMiseAJour.ANALYSE_MARGINALE,
                    libelle: "Analyse Marginale"
                  }
                ]
              : [])
          ]}
          cleOngletActif={ongletsActifs.formulaires}
          changerOnglet={valeur => changerOnglet(null, valeur)}
        />

        <div className="mt-4 flex h-[calc(100vh-16rem)] flex-col overflow-y-auto">
          {estMiseAJourAvecMentions && (
            <OngletsContenu estActif={ongletsActifs.formulaires === ECleOngletsMiseAJour.MENTIONS}>
              {acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits && (
                <div className="pb-4 text-left">
                  <ConteneurAvecBordure titreEnTete="Formule intégration dans RECE">
                    <div className="mt-3 bg-slate-400">{formuleDIntegration?.texteFormule}</div>
                  </ConteneurAvecBordure>
                </div>
              )}

              <Formik<IMiseAJourMentionsForm>
                initialValues={{ mentions: [] }}
                onSubmit={values => {
                  setMentionsDuTableau(values.mentions);
                }}
              >
                <Form>
                  <TableauMentions
                    setAfficherOngletAnalyseMarginale={setAfficherAnalyseMarginale}
                    setMotif={setMotif}
                    formulaireMentionEnCoursDeSaisie={formulaireMentionEnCoursDeSaisie}
                    donneesMentions={mentionsDeLActe}
                  />
                </Form>
              </Formik>
              <MentionForm
                titulaires={titulairesMention}
                setEnCoursDeSaisie={setFormulaireMentionEnCoursDeSaisie}
                enCoursDeSaisie={formulaireMentionEnCoursDeSaisie}
                setMentionEnCoursDeSaisie={setMentionEnCoursDeSaisie}
                natureActe={acte?.nature}
              />
            </OngletsContenu>
          )}

          {afficherAnalyseMarginale && (
            <OngletsContenu estActif={ongletsActifs.formulaires === ECleOngletsMiseAJour.ANALYSE_MARGINALE}>
              <AnalyseMarginaleFormulaire
                setDonneesAnalyseMarginale={setDonneesAnalyseMarginale}
                setAnalyseMarginaleModifiee={setAnalyseMarginaleModifiee}
                valeursInitiales={valeursInitialesFormulaireAnalyseMarginale}
                motif={motif}
              />
            </OngletsContenu>
          )}

          <ConteneurBoutonBasDePage position="droite">
            {estMiseAJourAvecMentions ? (
              <BoutonTerminerEtSigner
                saisieMentionEnCours={formulaireMentionEnCoursDeSaisie}
                acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits={acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits}
              />
            ) : (
              <BoutonValiderEtTerminer disabled={!miseAJourEffectuee} />
            )}
          </ConteneurBoutonBasDePage>
        </div>
      </div>
      {afficherModaleAnalyseMarginale && (
        <ConteneurModale>
          <div className="rounded-md border-[2px] border-solid border-bleu-sombre bg-blanc p-6 shadow-lg">
            <div className="p-6">{"Veuillez vérifier s'il y a lieu de mettre à jour l'analyse marginale"}</div>
            <Bouton
              title="J'ai lu ce message"
              onClick={() => {
                setAfficherModaleAnalyseMarginale(false);
              }}
            >
              {"OK"}
            </Bouton>
          </div>
        </ConteneurModale>
      )}
    </>
  );
};

export default PartieFormulaire;
