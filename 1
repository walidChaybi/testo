import { CONFIG_GET_RESUME_ACTE } from "@api/configurations/etatCivil/acte/GetResumeActeConfigApi";
import CONFIG_GET_FORMULE_INTEGRATION_RECE, {
  IFormuleIntegrationDto
} from "@api/configurations/etatCivil/nomenclature/GetFormuleIntegrationRECEApi";
import { CONFIG_PUT_ANALYSE_MARGINALE_ET_MENTIONS } from "@api/configurations/etatCivil/PutAnalyseMarginaleEtMentionsConfigApi";
import { CONFIG_PUT_MISE_A_JOUR_ANALYSE_MARGINALE } from "@api/configurations/etatCivil/PutMiseAJourAnalyseMarginaleConfigApi";
import { useMentionsApiHook } from "@hook/acte/mentions/MentionsApiHook";
import { Droit } from "@model/agent/enum/Droit";
import { TErreurApi } from "@model/api/Api";
import { FicheActe } from "@model/etatcivil/acte/FicheActe";
import { EStatutMention } from "@model/etatcivil/enum/EStatutMention";
import AnalyseMarginaleForm from "@model/form/AnalyseMarginale/AnalyseMarginaleForm";
import { TObjetFormulaire } from "@model/form/commun/ObjetFormulaire";
import { TPrenomsForm } from "@model/form/commun/PrenomsForm";
import MiseAJourForm from "@model/form/miseAJour/MiseAJourForm";
import { estActeEligibleFormuleDIntegration } from "@pages/fiche/FichePage";
import { Formik } from "formik";
import { useContext, useEffect, useMemo, useState } from "react";
import { Form } from "react-router";
import { ECleOngletsMiseAJour, EditionMiseAJourContext } from "../../../contexts/EditionMiseAJourContextProvider";
import { RECEContextData } from "../../../contexts/RECEContextProvider";
import useFetchApi from "../../../hooks/api/FetchApiHook";
import AfficherMessage from "../../../utils/AfficherMessage";
import Bouton from "../../commun/bouton/Bouton";
import { ConteneurBoutonBasDePage } from "../../commun/bouton/conteneurBoutonBasDePage/ConteneurBoutonBasDePage";
import PageChargeur from "../../commun/chargeurs/PageChargeur";
import ConteneurAvecBordure from "../../commun/conteneurs/formulaire/ConteneurAvecBordure";
import ConteneurModale from "../../commun/conteneurs/modale/ConteneurModale";
import OngletsBouton from "../../commun/onglets/OngletsBouton";
import OngletsContenu from "../../commun/onglets/OngletsContenu";
import BoutonTerminerEtSigner from "./formulaires/BoutonTerminerEtSigner";
import BoutonValiderEtTerminer from "./formulaires/BoutonValiderEtTerminer";
import MentionForm, { ITitulaireMention } from "./formulaires/MentionForm";
import AnalyseMarginaleFormulaire from "./formulaires/mentions/AnalyseMarginaleFormulaire/AnalyseMarginaleFormulaire";
import TableauMentions from "./formulaires/mentions/ListeMentionsFormulaire/TableauMentions";

interface IDonneesAideSaisie {
  champs: TObjetFormulaire;
  textesEdites: { [cle: string]: { edite: string; original: string } };
}

export interface IMentionMiseAJour {
  texte: string;
  idTypeMention: string;
  affecteAnalyseMarginale: boolean;
  donneesAideSaisie?: IDonneesAideSaisie;
}

export interface IMentionEnCours {
  index: number | null;
  mention: IMentionMiseAJour;
}

export interface IAnalyseMarginaleMiseAJour extends TObjetFormulaire {
  motif: string;
  titulaires: {
    nom: string;
    nomSecable: boolean;
    nomPartie1: string;
    nomPartie2: string;
    prenoms: TPrenomsForm;
  }[];
}

export interface IMiseAJourForm {
  mentions: IMentionMiseAJour[];
  analyseMarginale: IAnalyseMarginaleMiseAJour;
}

export interface IMiseAJourMentionsForm {
  mentions: IMentionMiseAJour[];
}

const PartieFormulaire: React.FC = () => {
  const { estMiseAJourAvecMentions, ongletsActifs, idActe, miseAJourEffectuee } = useContext(EditionMiseAJourContext.Valeurs);
  const { changerOnglet, activerOngletActeMisAJour, setComposerActeMisAJour } = useContext(EditionMiseAJourContext.Actions);

  const { appelApi: mettreAJourAnalyseMarginaleEtMentions, enAttenteDeReponseApi: enAttenteMiseAJourAnalyseMarginaleEtMention } =
    useFetchApi(CONFIG_PUT_ANALYSE_MARGINALE_ET_MENTIONS);
  const { appelApi: mettreAJourAnalyseMarginale, enAttenteDeReponseApi: enAttenteMiseAJourAnalyseMarginale } = useFetchApi(
    CONFIG_PUT_MISE_A_JOUR_ANALYSE_MARGINALE
  );
  const [afficherAnalyseMarginale, setAfficherAnalyseMarginale] = useState(!estMiseAJourAvecMentions);

  const [formulaireMentionEnCoursDeSaisie, setFormulaireMentionEnCoursDeSaisie] = useState<boolean>(false);

  const [afficherModaleAnalyseMarginale, setAfficherModaleAnalyseMarginale] = useState<boolean>(false);
  const [donneesAnalyseMarginale, setDonneesAnalyseMarginale] = useState<IAnalyseMarginaleMiseAJour | null>(null);
  const [analyseMarginaleModifiee, setAnalyseMarginaleModifiee] = useState<boolean>(false);
  const [mentionsDeLActe, setMentionsDeLActe] = useState<IMentionMiseAJour[]>([]);
  const [mentionsDuTableau, setMentionsDuTableau] = useState<IMentionMiseAJour[]>([]);
  const [mentionEnCoursDeSaisie, setMentionEnCoursDeSaisie] = useState<IMentionEnCours | null>(null);
  const [motif, setMotif] = useState<string | null>(null);

  const [acte, setActe] = useState<FicheActe | null>(null);
  const { appelApi: getResumeActe } = useFetchApi(CONFIG_GET_RESUME_ACTE, true);
  const { appelApi: getFormuleIntegrationRece } = useFetchApi(CONFIG_GET_FORMULE_INTEGRATION_RECE, true);
  const [valeursInitialesFormulaireAnalyseMarginale, setValeursInitialesFormulaireAnalyseMarginale] =
    useState<IAnalyseMarginaleMiseAJour | null>(null);
  const { utilisateurConnecte } = useContext(RECEContextData);

  const [formuleDIntegration, setFormuleDIntegration] = useState<IFormuleIntegrationDto | null>(null);

  // Charger les mentions existantes pour les actes déjà numérisés
  const estActeDejaNumérisé = acte?.origine === "SCEC_DOCS" && acte?.referenceActe?.startsWith("RECE.");
  const mentionsExistantes = useMentionsApiHook(estActeDejaNumérisé ? { idActe: idActe, statutMention: EStatutMention.SIGNEE } : undefined);

  const acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits = useMemo(() => {
    if (acte !== null) {
      return (
        estActeEligibleFormuleDIntegration(acte) &&
        utilisateurConnecte.estHabilitePour({ tousLesDroits: [Droit.METTRE_A_JOUR_ACTE, Droit.MISE_A_JOUR_CREER_DOUBLE_NUMERIQUE] })
      );
    }
    return false;
  }, [acte, utilisateurConnecte]);

  useEffect(() => {
    if (acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits && formuleDIntegration === null) {
      getFormuleIntegrationRece({
        parametres: {},
        apresSucces: formuleDIntegration => {
          setFormuleDIntegration(formuleDIntegration);
        },
        apresErreur: erreurs =>
          AfficherMessage.erreur("Une erreur est survenue lors de la récupération des informations de la formule d'intégration au RECE", {
            erreurs
          })
      });
    }
  }, [acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits]);

  useEffect(() => {
    if (estMiseAJourAvecMentions) {
      let mentions: IMentionMiseAJour[];
      const analyseMarginaleEstMiseAJour = afficherAnalyseMarginale && analyseMarginaleModifiee && donneesAnalyseMarginale !== null;

      // Mention saisie dans le formulaire de saisie
      if (mentionEnCoursDeSaisie?.mention) {
        // Mention modifiée
        if (typeof mentionEnCoursDeSaisie.index === "number") {
          if (mentionsDeLActe[mentionEnCoursDeSaisie.index] === mentionEnCoursDeSaisie.mention) return;

          mentions = mentionsDeLActe.map((mention, index) =>
            index === mentionEnCoursDeSaisie.index ? mentionEnCoursDeSaisie.mention : mention
          );

          // Mention ajoutée
        } else {
          mentions = [...mentionsDeLActe, mentionEnCoursDeSaisie.mention];
        }

        // Analyse marginale modifiée
      } else if (analyseMarginaleEstMiseAJour) {
        mentions = mentionsDeLActe;

        // Ordre des mentions modifié ou mention supprimée
      } else {
        mentions = mentionsDuTableau;
      }

      if (!mentions.length) return;

      mettreAJourAnalyseMarginaleEtMentions({
        parametres: {
          body: MiseAJourForm.versDto(
            idActe,
            [
              ...mentions,
              ...(formuleDIntegration !== null
                ? [
                    {
                      idTypeMention: formuleDIntegration.idTypeMention,
                      affecteAnalyseMarginale: formuleDIntegration.affecteAnalyseMarginale,
                      texte: formuleDIntegration.texteFormule
                    }
                  ]
                : [])
            ],
            donneesAnalyseMarginale,
            analyseMarginaleEstMiseAJour
          )
        },
        apresSucces: () => {
          setMentionsDeLActe(mentions);
          activerMiseAJourActe();
          resetModificationMention();

          !analyseMarginaleEstMiseAJour &&
            setAfficherModaleAnalyseMarginale(mentions[mentionEnCoursDeSaisie?.index ?? mentions.length - 1].affecteAnalyseMarginale);
        },
        apresErreur: (erreurs: TErreurApi[]) => {
          const messageErreur = (() => {
            switch (true) {
              case Boolean(erreurs?.find(erreur => erreur.code === "FCT_16136")):
                return "Aucune modification de l'analyse marginale n'a été détectée";
              case Boolean(erreurs?.find(erreur => erreur.code === "FCT_160168")):
                return "La personne liée ne peut pas être le titulaire de l'acte";
              default:
                return "Impossible de mettre à jour l'acte";
            }
          })();

          AfficherMessage.erreur(messageErreur, { erreurs, fermetureAuto: true });
        }
      });
    }

    if (!estMiseAJourAvecMentions && donneesAnalyseMarginale !== null) {
      mettreAJourAnalyseMarginale({
        parametres: {
          path: { idActe: idActe },
          body: AnalyseMarginaleForm.versDto(donneesAnalyseMarginale)
        },
        apresSucces: () => {
          activerOngletActeMisAJour();
          setComposerActeMisAJour(true);
          changerOnglet(ECleOngletsMiseAJour.ACTE_MIS_A_JOUR, null);
        },
        apresErreur: (erreurs: TErreurApi[]) => {
          const messageErreur = erreurs.find(erreur => erreur.code === "FCT_16136")
            ? "Aucune modification de l'analyse marginale n'a été détectée"
            : "Impossible de mettre à jour l'analyse marginale";

          AfficherMessage.erreur(messageErreur, { erreurs, fermetureAuto: true });
        }
      });
    }
  }, [donneesAnalyseMarginale, mentionEnCoursDeSaisie, mentionsDuTableau]);

  useEffect(() => {
    getResumeActe({
      parametres: {
        path: { idActe },
        query: { remplaceIdentiteTitulaireParIdentiteTitulaireAM: true }
      },
      apresSucces: acteDto => {
        setActe(FicheActe.depuisDto(acteDto));
      },
      apresErreur: erreurs =>
        AfficherMessage.erreur("Une erreur est survenue lors de la récupération des informations de l'acte", { erreurs })
    });
  }, []);

  useEffect(() => {
    if (!acte) return;

    setValeursInitialesFormulaireAnalyseMarginale(
      AnalyseMarginaleForm.genererValeursDefautFormulaire(acte.getTitulairesPourAnalyseMarginale(), motif)
    );
  }, [motif, acte]);

  // Charger les mentions existantes pour les actes déjà numérisés (SCEC_DOCS avec référence RECE)
  useEffect(() => {
    if (mentionsExistantes?.mentions) {
      const mentionsConverties: IMentionMiseAJour[] = mentionsExistantes.mentions
        .filter(mention => {
          // Exclure la formule d'intégration (vérifier via le texte ou l'id du type mention)
          const estFormuleIntegration = mention.textes?.texteMention?.includes("intégré au registre électronique sous la référence");
          return !estFormuleIntegration;
        })
        .map(mention => ({
          texte: mention.textes?.texteMention ?? "",
          idTypeMention: mention.typeMention?.id ?? "",
          affecteAnalyseMarginale: mention.typeMention?.affecteAnalyseMarginale ?? false
        }));
      setMentionsDeLActe(mentionsConverties);
    }
  }, [mentionsExistantes]);

  const resetModificationMention = () => {
    setMentionEnCoursDeSaisie(mention => (mention ? null : mention));
    setMentionsDuTableau(mentions => (mentions.length > 0 ? [] : mentions));
    setFormulaireMentionEnCoursDeSaisie(false);
  };

  const activerMiseAJourActe = () => {
    activerOngletActeMisAJour();
    setComposerActeMisAJour(true);
    changerOnglet(ECleOngletsMiseAJour.ACTE_MIS_A_JOUR, null);
  };

  const titulairesMention: ITitulaireMention[] = useMemo(() => {
    if (!acte) return [];

    return [...Array(acte.getNombreTitulairesSelonNature()).keys()].map(index => {
      return {
        nom: acte?.titulaires?.[index].nom ?? "",
        nomPartie1: acte?.titulaires?.[index].nomPartie1 ?? "",
        nomPartie2: acte?.titulaires?.[index].nomPartie2 ?? "",
        nomSecable: Boolean(acte?.titulaires?.[index].nomPartie1 && acte?.titulaires?.[index].nomPartie2),
        prenoms: acte?.titulaires?.[index].prenoms ?? [],
        sexe: acte?.titulaires?.[index].sexe ?? null
      };
    });
  }, [acte]);

  return (
    <>
      {(enAttenteMiseAJourAnalyseMarginale || enAttenteMiseAJourAnalyseMarginaleEtMention) && <PageChargeur />}
      <div className="w-1/2">
        <OngletsBouton<ECleOngletsMiseAJour>
          onglets={[
            ...(estMiseAJourAvecMentions
              ? [
                  {
                    cle: ECleOngletsMiseAJour.MENTIONS,
                    libelle: "Mentions"
                  }
                ]
              : []),

            ...(afficherAnalyseMarginale
              ? [
                  {
                    cle: ECleOngletsMiseAJour.ANALYSE_MARGINALE,
                    libelle: "Analyse Marginale"
                  }
                ]
              : [])
          ]}
          cleOngletActif={ongletsActifs.formulaires}
          changerOnglet={valeur => changerOnglet(null, valeur)}
        />

        <div className="mt-4 flex h-[calc(100vh-16rem)] flex-col overflow-y-auto">
          {estMiseAJourAvecMentions && (
            <OngletsContenu estActif={ongletsActifs.formulaires === ECleOngletsMiseAJour.MENTIONS}>
              {acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits && (
                <div className="pb-4 text-left">
                  <ConteneurAvecBordure titreEnTete="Formule intégration dans RECE">
                    <div className="mt-3 bg-slate-400">{formuleDIntegration?.texteFormule}</div>
                  </ConteneurAvecBordure>
                </div>
              )}

              <Formik<IMiseAJourMentionsForm>
                initialValues={{ mentions: [] }}
                onSubmit={values => {
                  setMentionsDuTableau(values.mentions);
                }}
              >
                <Form>
                  <TableauMentions
                    setAfficherOngletAnalyseMarginale={setAfficherAnalyseMarginale}
                    setMotif={setMotif}
                    formulaireMentionEnCoursDeSaisie={formulaireMentionEnCoursDeSaisie}
                    donneesMentions={mentionsDeLActe}
                  />
                </Form>
              </Formik>
              <MentionForm
                titulaires={titulairesMention}
                setEnCoursDeSaisie={setFormulaireMentionEnCoursDeSaisie}
                enCoursDeSaisie={formulaireMentionEnCoursDeSaisie}
                setMentionEnCoursDeSaisie={setMentionEnCoursDeSaisie}
                natureActe={acte?.nature}
              />
            </OngletsContenu>
          )}

          {afficherAnalyseMarginale && (
            <OngletsContenu estActif={ongletsActifs.formulaires === ECleOngletsMiseAJour.ANALYSE_MARGINALE}>
              <AnalyseMarginaleFormulaire
                setDonneesAnalyseMarginale={setDonneesAnalyseMarginale}
                setAnalyseMarginaleModifiee={setAnalyseMarginaleModifiee}
                valeursInitiales={valeursInitialesFormulaireAnalyseMarginale}
                motif={motif}
              />
            </OngletsContenu>
          )}

          <ConteneurBoutonBasDePage position="droite">
            {estMiseAJourAvecMentions ? (
              <BoutonTerminerEtSigner
                saisieMentionEnCours={formulaireMentionEnCoursDeSaisie}
                acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits={acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits}
                nombreMentionsAjoutees={mentionsDeLActe.length}
              />
            ) : (
              <BoutonValiderEtTerminer disabled={!miseAJourEffectuee} />
            )}
          </ConteneurBoutonBasDePage>
        </div>
      </div>
      {afficherModaleAnalyseMarginale && (
        <ConteneurModale>
          <div className="rounded-md border-[2px] border-solid border-bleu-sombre bg-blanc p-6 shadow-lg">
            <div className="p-6">{"Veuillez vérifier s'il y a lieu de mettre à jour l'analyse marginale"}</div>
            <Bouton
              title="J'ai lu ce message"
              onClick={() => {
                setAfficherModaleAnalyseMarginale(false);
              }}
            >
              {"OK"}
            </Bouton>
          </div>
        </ConteneurModale>
      )}
    </>
  );
};

export default PartieFormulaire;
import { CONFIG_POST_REQUETE_MISE_A_JOUR } from "@api/configurations/requete/miseAJour/PostRequeteMiseAJourApiConfig";
import { AddAlerteActeApiHookParameters, useAddAlerteActeApiHook } from "@hook/alertes/AddAlerteActeHookApi";
import { DeleteAlerteActeApiHookParameters, useDeleteAlerteActeApiHook } from "@hook/alertes/DeleteAlerteActeHookApi";
import { Droit } from "@model/agent/enum/Droit";
import { Perimetre } from "@model/agent/enum/Perimetre";
import { FicheActe } from "@model/etatcivil/acte/FicheActe";
import { ETypeActe } from "@model/etatcivil/enum/ETypeActe";
import { ETypeFiche } from "@model/etatcivil/enum/ETypeFiche";
import { EOptionMiseAJourActe, OptionMiseAJourActe } from "@model/etatcivil/enum/OptionMiseAJourActe";
import { TitulaireRequeteMiseAJour } from "@model/requete/ITitulaireRequeteMiseAJour";
import { SousTypeMiseAJour } from "@model/requete/enum/SousTypeMiseAJour";
import { UN } from "@util/Utils";
import { FeatureFlag } from "@util/featureFlag/FeatureFlag";
import { gestionnaireFeatureFlag } from "@util/featureFlag/gestionnaireFeatureFlag";
import { AccordionRece } from "@widget/accordion/AccordionRece";
import { IAjouterAlerteFormValue } from "@widget/alertes/ajouterAlerte/contenu/PopinAjouterAlertes";
import { OperationLocaleEnCours } from "@widget/attente/OperationLocaleEnCours";
import { BoutonMenu } from "@widget/boutonMenu/BoutonMenu";
import { BarreNavigationSuivPrec } from "@widget/navigation/barreNavigationSuivPrec/BarreNavigationSuivPrec";
import { SectionPanelProps } from "@widget/section/SectionPanel";
import { SectionPanelAreaProps } from "@widget/section/SectionPanelArea";
import React, { useCallback, useContext, useEffect, useMemo, useState } from "react";
import { useNavigate } from "react-router";
import { IFenetreExterneRef } from "../../../composants/commun/conteneurs/FenetreExterne";
import { RECEContextData } from "../../../contexts/RECEContextProvider";
import useFetchApi from "../../../hooks/api/FetchApiHook";
import LiensRECE from "../../../router/LiensRECE";
import {
  INFO_PAGE_MISE_A_JOUR_ANALYSE_MARGINALE,
  INFO_PAGE_MISE_A_JOUR_MENTION_AUTRE,
  INFO_PAGE_MISE_A_JOUR_MENTION_SUITE_AVIS
} from "../../../router/infoPages/InfoPagesEspaceMiseAJour";
import AfficherMessage from "../../../utils/AfficherMessage";
import { BoutonCreationRDD } from "./BoutonCreationRDD/BoutonCreationRDD";
import { setFiche } from "./FicheUtils";
import { BandeauAlertesActe } from "./contenu/BandeauAlertesActe";
import { BandeauFiche } from "./contenu/BandeauFiche";
import { BandeauFicheActeNumero } from "./contenu/BandeauFicheActeNumero";
import { BandeauFicheRcRcaPacsNumero } from "./contenu/BandeauFicheRcRcaPacsNumero";
import { useFichePageApiHook } from "./hook/FichePageApiHook";
import "./scss/FichePage.scss";

export interface IIndex {
  value: number;
}

interface IFichePageProps {
  datasFiches: IDataFicheProps[];
  index: IIndex;
  numeroRequete?: string;
  fenetreExterneRef?: IFenetreExterneRef;
  nbLignesTotales: number;
  nbLignesParAppel: number;
}

export interface IDataFicheProps {
  identifiant: string;
  categorie: ETypeFiche;
}

export const estActeEligibleFormuleDIntegration = ({
  origine,
  referenceActe,
  referenceRegistreSansNumeroDActe,
  type
}: FicheActe): boolean => {
  const estOrigineScecDocs = origine === "SCEC_DOCS";
  const referenceRegistreSansNumeroDActeAbsente = !referenceRegistreSansNumeroDActe?.trim();
  const estTypeTexte = type === ETypeActe.TEXTE;
  const ReferenceRECE = referenceActe?.startsWith("RECE.");

  console.log(referenceRegistreSansNumeroDActe);

  return estOrigineScecDocs && !ReferenceRECE && referenceRegistreSansNumeroDActeAbsente && estTypeTexte;
};

export const FichePage: React.FC<IFichePageProps> = ({
  datasFiches,
  numeroRequete,
  index,
  fenetreExterneRef,
  nbLignesTotales,
  nbLignesParAppel
}) => {
  const navigate = useNavigate();
  const [actualisationInfosFiche, setActualisationInfosFiche] = useState<boolean>(false);
  const [ficheCourante, setFicheCourante] = useState<IDataFicheProps | undefined>(
    datasFiches[getIndexLocal(index.value, nbLignesParAppel)]
  );
  const [optionMiseAJour, setOptionMiseAJour] = useState<EOptionMiseAJourActe | null>(null);
  // index courant sur la totalité des données
  const [indexCourant, setIndexCourant] = useState<number>(index.value);

  const { appelApi: appelPostRequeteMiseAJour } = useFetchApi(CONFIG_POST_REQUETE_MISE_A_JOUR);

  useEffect(() => {
    setFicheCourante(datasFiches[getIndexLocal(indexCourant, nbLignesParAppel)]);
  }, [datasFiches]);

  // (*) Permet de résoudre le pb de la fenêtre fiche déjà ouverte
  // Si l'utilisateur clique sur une fenêtre fiche déjà ouverte (et qu'il a déjà navigué dedans) alors l'index aura changé (cf. onClickOnLine RMCTableauActes par exemple ),
  //   on peut ainsi mettre à jour l'index courant avec l'index passé en props
  // A noté que ce useEffect passe après le précédent et qu'il écrase donc la ficheCourante précédemment mise à jour par le useEffect ci-dessus
  useEffect(() => {
    setIndexCourant(index.value);
    setFicheCourante(datasFiches[getIndexLocal(index.value, nbLignesParAppel)]);
  }, [index]);

  const { utilisateurConnecte } = useContext(RECEContextData);

  const fiche = useFichePageApiHook(actualisationInfosFiche, ficheCourante?.categorie, ficheCourante?.identifiant);

  const { bandeauFiche, panelsFiche, alertes, visuBoutonAlertes } = setFiche(utilisateurConnecte, ficheCourante, fiche);

  const droitsMiseAJour = useMemo(() => {
    const droitMentions = utilisateurConnecte.estHabilitePour({ leDroit: Droit.METTRE_A_JOUR_ACTE });
    const droitAnalyseMarginale = utilisateurConnecte.estHabilitePour({ leDroit: Droit.MODIFIER_ANALYSE_MARGINALE });
    const droitCreationDoubleNumerique = utilisateurConnecte.estHabilitePour({ leDroit: Droit.MISE_A_JOUR_CREER_DOUBLE_NUMERIQUE });

    if (!fiche) {
      return {
        autorise: false,
        mentions: droitMentions,
        AnalyseMarginale: droitAnalyseMarginale
      };
    }

    let autorise = false;
    let peutMettreAJourSansRECE = false;

    if (ficheCourante?.categorie === ETypeFiche.ACTE && "titulaires" in fiche && fiche.statut !== "BROUILLON") {
      const estOrigineRece = fiche?.origine === "RECE";
      const acteSansReceEligible = estActeEligibleFormuleDIntegration(fiche);

      const estActeScecDocsNumerise = fiche?.origine === "SCEC_DOCS" && fiche?.referenceActe?.startsWith("RECE.");

      const peutMettreAJourSansRECE = acteSansReceEligible && droitMentions && droitCreationDoubleNumerique;

      autorise =
        (estOrigineRece && (droitMentions || droitAnalyseMarginale)) ||
        peutMettreAJourSansRECE ||
        (estActeScecDocsNumerise && droitMentions);
    }

    return {
      autorise,
      mentions: droitMentions || peutMettreAJourSansRECE,
      AnalyseMarginale: droitAnalyseMarginale
    };
  }, [fiche, ficheCourante, utilisateurConnecte]);

  useEffect(() => {
    const idActe = fiche?.id;
    if (!optionMiseAJour || !idActe || !(fiche instanceof FicheActe)) return;

    const estAnalyseMarginale = optionMiseAJour === EOptionMiseAJourActe.ANALYSE_MARGINALE;
    const sousTypeOptionMiseAJour = OptionMiseAJourActe.getSousType(optionMiseAJour);

    appelPostRequeteMiseAJour({
      parametres: {
        body: {
          idActeMAJ: idActe,
          choixMAJ: estAnalyseMarginale ? "MAJ_ACTE_ANALYSE_MARGINALE" : "MAJ_ACTE_APPOSER_MENTION",
          sousType: sousTypeOptionMiseAJour.nom,
          titulaires: TitulaireRequeteMiseAJour.listeDepuisDonneesFiche(fiche.titulaires)
        }
      },
      apresSucces: reponse => {
        const urlNavigation = (() => {
          switch (true) {
            case estAnalyseMarginale:
              return LiensRECE.genererLien(INFO_PAGE_MISE_A_JOUR_ANALYSE_MARGINALE.url, {
                idRequeteParam: reponse.id,
                idActeParam: idActe
              });
            case SousTypeMiseAJour.estRMAC(sousTypeOptionMiseAJour):
              return LiensRECE.genererLien(INFO_PAGE_MISE_A_JOUR_MENTION_SUITE_AVIS.url, {
                idRequeteParam: reponse.id,
                idActeParam: idActe
              });
            default:
              return LiensRECE.genererLien(INFO_PAGE_MISE_A_JOUR_MENTION_AUTRE.url, { idRequeteParam: reponse.id, idActeParam: idActe });
          }
        })();

        navigate(urlNavigation);
      },
      apresErreur: erreurs => {
        const messageErreur = erreurs.find(erreur => erreur.code === "FCT_15181")?.message;

        AfficherMessage.erreur(messageErreur ?? "Impossible d'accéder à la requête de mise à jour de l'acte", {
          erreurs
        });
      },
      finalement: () => setOptionMiseAJour(null)
    });
  }, [optionMiseAJour]);

  // Obligatoire pour les styles qui sont chargés dynamiquement
  useEffect(() => {
    if (fiche && fiche.id === ficheCourante?.identifiant) {
      if (fiche != null) {
        const event = new CustomEvent("refreshStyles");
        if (window.top) {
          window.top.dispatchEvent(event);
        }
      }
      if (fenetreExterneRef && bandeauFiche) {
        fenetreExterneRef.ref.document.title = bandeauFiche.titreFenetre;
      }
    }
  }, [fiche, fenetreExterneRef, bandeauFiche, ficheCourante]);

  const setIndexFiche = useCallback(
    (idx: number) => {
      if (ficheCourante && datasFiches && idx >= 0 && idx < nbLignesTotales) {
        setFicheCourante(datasFiches[getIndexLocal(idx, nbLignesParAppel)]);
      }
      setIndexCourant(idx);
    },
    [ficheCourante, datasFiches, indexCourant, nbLignesParAppel, nbLignesTotales]
  );

  /* Ajout d'une alerte */
  const [ajouterAlerteActeApiHookParameters, setAjouterAlerteActeApiHookParameters] = useState<AddAlerteActeApiHookParameters>();

  const ajouterAlerteCallBack = useCallback(
    (value: IAjouterAlerteFormValue) => {
      setAjouterAlerteActeApiHookParameters({
        idActe: fiche?.id ?? "",
        idTypeAlerte: value?.idTypeAlerte,
        complementDescription: value?.complementDescription
      });
    },
    [fiche]
  );

  const alerte = useAddAlerteActeApiHook(ajouterAlerteActeApiHookParameters);

  /* Suppression d'une alerte */
  const [deleteAlerteActeApiHookParameters, setDeleteAlerteActeApiHookParameters] = useState<DeleteAlerteActeApiHookParameters>();

  const supprimerAlerteCallBack = useCallback((idAlerteActe: string, idActe: string) => {
    setDeleteAlerteActeApiHookParameters({
      idAlerteActe,
      idActe
    });
  }, []);

  const resultatSuppressionAlerte = useDeleteAlerteActeApiHook(deleteAlerteActeApiHookParameters);

  useEffect(() => {
    if (alerte || resultatSuppressionAlerte) {
      setActualisationInfosFiche(!actualisationInfosFiche);
    }
  }, [alerte, resultatSuppressionAlerte]);

  return (
    <div className="FichePage">
      {bandeauFiche && panelsFiche && fiche && ficheCourante ? (
        <>
          <BandeauFiche
            dataBandeau={bandeauFiche}
            elementNumeroLigne={
              ficheCourante.categorie === ETypeFiche.ACTE ? (
                <BandeauFicheActeNumero dataBandeau={bandeauFiche} />
              ) : (
                <BandeauFicheRcRcaPacsNumero dataBandeau={bandeauFiche} />
              )
            }
          />

          {datasFiches.length > UN && (
            <div className="barreNavigationSuivPrec">
              <BarreNavigationSuivPrec
                index={indexCourant}
                max={nbLignesTotales}
                setIndex={setIndexFiche}
              />
            </div>
          )}

          {fiche instanceof FicheActe && ficheCourante.categorie === ETypeFiche.ACTE && (
            <div className="headerFichePage">
              <BandeauAlertesActe
                alertes={alertes}
                idTypeRegistre={fiche?.registre?.type?.id}
                ajouterAlerteCallBack={ajouterAlerteCallBack}
                supprimerAlerteCallBack={supprimerAlerteCallBack}
                afficherBouton={visuBoutonAlertes}
                disableScrollLock={true}
              />
              {droitsMiseAJour.autorise && (
                <BoutonMenu
                  boutonLibelle="Mettre à jour"
                  className="menuMettreAJour"
                  options={OptionMiseAJourActe.commeOptions({
                    mentions: droitsMiseAJour.mentions,
                    analyseMarginale: droitsMiseAJour.AnalyseMarginale
                  })}
                  onClickOption={option => setOptionMiseAJour(option as EOptionMiseAJourActe)}
                  anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
                  transformOrigin={{ vertical: "top", horizontal: "right" }}
                  disableScrollLock={true}
                />
              )}
              {fiche &&
                !(
                  utilisateurConnecte.estHabilitePour({
                    leDroit: Droit.CONSULTER,
                    pourIdTypeRegistre: fiche.registre?.type?.id
                  }) || utilisateurConnecte.estHabilitePour({ leDroit: Droit.CONSULTER, surLePerimetre: Perimetre.TOUS_REGISTRES })
                ) &&
                gestionnaireFeatureFlag.estActif(FeatureFlag.FF_DELIVRANCE_CIBLE_EXTRAITS_COPIES) && (
                  <BoutonCreationRDD
                    label="Demander la délivrance"
                    labelPopin={`Vous allez demander la délivrance de cet acte. Souhaitez-vous continuer ?`}
                    acte={fiche}
                    numeroFonctionnel={numeroRequete}
                  />
                )}
            </div>
          )}

          {panelsFiche?.panels.map((panel: SectionPanelProps, idx: number) => (
            <AccordionRece
              key={`accordion-rece-${idx}`}
              panel={panel}
              index={idx}
              expanded={panelsFiche.panelParDefaut ? idx === panelsFiche.panelParDefaut : idx === 0}
              titre={panel?.title}
              disabled={panel?.panelAreas.every((pa: SectionPanelAreaProps) => !pa.value && !pa.parts)}
            />
          ))}
        </>
      ) : (
        <OperationLocaleEnCours visible={true} />
      )}
    </div>
  );
};

/**
 * Retourne l'index local à la "plage" courante (ie "datasFiches").
 * En effet, "indexCourant" est l'index sur la totalité des données mais dépasse peut être la taille de datasFiches
 */
function getIndexLocal(index: number, nbLignesParAppel: number) {
  return index % nbLignesParAppel;
}
import { Droit } from "@model/agent/enum/Droit";
import { useContext, useMemo, useState } from "react";
import { ECleOngletsMiseAJour, EditionMiseAJourContext } from "../../../../contexts/EditionMiseAJourContextProvider";
import { RECEContextData } from "../../../../contexts/RECEContextProvider";
import AfficherMessage from "../../../../utils/AfficherMessage";
import Bouton from "../../../commun/bouton/Bouton";
import ConteneurModale from "../../../commun/conteneurs/modale/ConteneurModale";
import SignatureDocument from "../../../commun/signature/SignatureDocument";

interface IBoutonTerminerEtSignerProps {
  saisieMentionEnCours: boolean;
  acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits: boolean;
  nombreMentionsAjoutees: number;
}

const BoutonTerminerEtSigner: React.FC<IBoutonTerminerEtSignerProps> = ({
  saisieMentionEnCours,
  acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits,
  nombreMentionsAjoutees
}) => {
  const { utilisateurConnecte } = useContext(RECEContextData);
  const { idActe, idRequete, miseAJourEffectuee } = useContext(EditionMiseAJourContext.Valeurs);
  const { setEstActeSigne, desactiverBlocker, changerOnglet } = useContext(EditionMiseAJourContext.Actions);
  const aDroitSigner = useMemo<boolean>(
    () => utilisateurConnecte.estHabilitePour({ tousLesDroits: [Droit.SIGNER_MENTION, Droit.METTRE_A_JOUR_ACTE] }),
    [utilisateurConnecte]
  );
  const [modaleOuverte, setModaleOuverte] = useState<boolean>(false);

  // Pour les actes sans RECE en cours de numérisation, au moins une mention manuelle est obligatoire
  const mentionsObligatoiresManquantes = acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits && nombreMentionsAjoutees === 0;
  const boutonDesactive = saisieMentionEnCours || !miseAJourEffectuee || mentionsObligatoiresManquantes;
  const titreBouton = mentionsObligatoiresManquantes
    ? "Ajoutez au moins une mention apposée manuellement avant de signer"
    : "Terminer et signer";

  if (!aDroitSigner) return <></>;

  return (
    <>
      <Bouton
        type="button"
        title={titreBouton}
        onClick={() => {
          if (mentionsObligatoiresManquantes) {
            AfficherMessage.erreur("Au moins une mention apposée manuellement doit être ajoutée avant de pouvoir signer.", {
              fermetureAuto: true
            });
            return;
          }
          setModaleOuverte(true);
        }}
        disabled={boutonDesactive}
      >
        {"Terminer et signer"}
      </Bouton>

      {modaleOuverte && (
        <ConteneurModale>
          <div className="border-3 w-[34rem] max-w-full rounded-xl border-solid border-bleu-sombre bg-blanc p-5">
            <h2 className="m-0 mb-4 text-center font-medium text-bleu-sombre">{"Signature des mentions"}</h2>
            <SignatureDocument
              typeSignature={acteEstEligibleFormuleDIntegrationEtUtilisateurALesDroits ? "DOUBLE_NUMERIQUE" : "MISE_A_JOUR"}
              idActe={idActe}
              idRequete={idRequete}
              apresSignature={(succes: boolean) => {
                setModaleOuverte(false);
                if (!succes) return;

                changerOnglet(ECleOngletsMiseAJour.ACTE, null);
                setEstActeSigne(true);
                AfficherMessage.succes("L'acte a été mis à jour avec succès.", { fermetureAuto: true });
                desactiverBlocker();
              }}
            />
          </div>
        </ConteneurModale>
      )}
    </>
  );
};

export default BoutonTerminerEtSigner;
import { IMentionMiseAJourDto } from "@hook/acte/mentions/MiseAJourMentionsApiHook";
import { champsObligatoiresDuDtoAbsents, valeurDtoAbsenteDansEnum } from "@model/commun/dtoUtils";
import { TDateArrayDTO } from "@util/DateUtils";
import {
  premiereLettreEnMinuscule,
  SNP,
  SPC,
  supprimeSautDeLigneEtEspaceInutiles,
  triListeObjetsSurDate,
  triListeObjetsSurPropriete
} from "@util/Utils";
import DateRECE from "../../../utils/DateRECE";
import { ChoixDelivrance } from "../../requete/enum/ChoixDelivrance";
import { IPersonneDTO, Personne } from "../commun/Personne";
import { EOrigineActe } from "../enum/EOrigineActe";
import { EStatutActe } from "../enum/EStatutActe";
import { ETypeActe } from "../enum/ETypeActe";
import { ENatureActe } from "../enum/NatureActe";
import { NATIONALITE, NatureMention } from "../enum/NatureMention";
import { ETypeVisibiliteArchiviste } from "../enum/TypeVisibiliteArchiviste";
import { AlerteFicheActe, IAlerteFicheActeDto } from "../fiche/AlerteFicheActe";
import { AnalyseMarginale, IAnalyseMarginaleDto } from "./AnalyseMarginale";
import { DetailMariage, IDetailMariageDto } from "./DetailMariage";
import { ICorpsTexte } from "./ICorpsTexte";
import { IEvenementDto } from "./IEvenement";
import { TypeMention } from "./mention/ITypeMention";
import { IMentionDto, Mention } from "./mention/Mention";
import { IRectificationCorpsExtraitDto, RectificationCorpsExtrait } from "./RectificationCorpsExtrait";
import { IRegistreDto, Registre } from "./Registre";
import { ITitulaireActeDto, TitulaireActe } from "./TitulaireActe";

export interface IFicheActeDto {
  id: string;
  evenement?: IEvenementDto;
  numero?: string;
  numeroBisTer?: string;
  titulaires: ITitulaireActeDto[];
  personnes: IPersonneDTO[];
  estReecrit?: boolean;
  registre?: IRegistreDto;
  dateDerniereMaj?: TDateArrayDTO;
  dateDerniereDelivrance?: number;
  nature: keyof typeof ENatureActe;
  visibiliteArchiviste: keyof typeof ETypeVisibiliteArchiviste;
  origine: keyof typeof EOrigineActe;
  type: keyof typeof ETypeActe;
  statut: keyof typeof EStatutActe;
  analyseMarginales: IAnalyseMarginaleDto[];
  corpsExtraitRectifications: IRectificationCorpsExtraitDto[];
  mentions: IMentionDto[];
  alerteActes: IAlerteFicheActeDto[];
  detailMariage?: IDetailMariageDto;
  corpsTexte?: ICorpsTexte;
  referenceActe: string;
  referenceRegistreSansNumeroDActe?: string;
}

export class FicheActe {
  private static readonly champsObligatoires: (keyof IFicheActeDto)[] = [
    "id",
    "titulaires",
    "nature",
    "personnes",
    "visibiliteArchiviste",
    "analyseMarginales",
    "type",
    "corpsExtraitRectifications",
    "mentions",
    "referenceActe",
    "origine",
    "statut",
    "alerteActes"
  ];

  private constructor(
    public readonly id: string,
    public readonly referenceActe: string,
    public readonly titulaires: TitulaireActe[],
    public readonly personnes: Personne[],
    public readonly type: keyof typeof ETypeActe,
    public readonly nature: keyof typeof ENatureActe,
    public readonly statut: keyof typeof EStatutActe,
    public readonly origine: keyof typeof EOrigineActe,
    public readonly visibiliteArchiviste: keyof typeof ETypeVisibiliteArchiviste,
    public readonly analysesMarginales: AnalyseMarginale[],
    public readonly rectificationsCorpsExtrait: RectificationCorpsExtrait[],
    public readonly mentions: Mention[],
    public readonly alertes: AlerteFicheActe[],
    public readonly numero: string | null,
    public readonly registre: Registre | null,
    public readonly dateDerniereMaj: DateRECE | null,
    public readonly dateDerniereDelivrance: DateRECE | null,
    public readonly numeroBisTer: string | null,
    public readonly referenceRegistreSansNumeroDActe: string | null,
    public readonly evenement: IEvenementDto | null,
    public readonly detailMariage: DetailMariage | null,
    public readonly estReecrit: boolean | null,
    public readonly corpsTexte: ICorpsTexte | null
  ) {}

  public static readonly depuisDto = (ficheActe: IFicheActeDto): FicheActe | null => {
    switch (true) {
      case champsObligatoiresDuDtoAbsents("IFicheActeDto", ficheActe, this.champsObligatoires):
      case valeurDtoAbsenteDansEnum("IFicheActeDto", ficheActe, "type", ETypeActe):
      case valeurDtoAbsenteDansEnum("IFicheActeDto", ficheActe, "nature", ENatureActe):
      case valeurDtoAbsenteDansEnum("IFicheActeDto", ficheActe, "statut", EStatutActe):
      case valeurDtoAbsenteDansEnum("IFicheActeDto", ficheActe, "origine", EOrigineActe):
      case valeurDtoAbsenteDansEnum("IFicheActeDto", ficheActe, "visibiliteArchiviste", ETypeVisibiliteArchiviste):
        return null;
    }

    const registre = ficheActe.registre ? Registre.depuisDto(ficheActe.registre) : null;

    return new FicheActe(
      ficheActe.id,
      ficheActe.referenceActe,
      triListeObjetsSurPropriete(
        ficheActe.titulaires.map(TitulaireActe.depuisDto).filter((titulaire): titulaire is TitulaireActe => titulaire !== null),
        "ordre"
      ),
      ficheActe.personnes.map(personne => Personne.depuisDto(personne)).filter((personne): personne is Personne => personne !== null),
      ficheActe.type,
      ficheActe.nature,
      ficheActe.statut,
      ficheActe.origine,
      ficheActe.visibiliteArchiviste,
      ficheActe.analyseMarginales.map(AnalyseMarginale.depuisDto).filter((am): am is AnalyseMarginale => am !== null),
      ficheActe.corpsExtraitRectifications
        .map(RectificationCorpsExtrait.depuisDto)
        .filter((rectification): rectification is RectificationCorpsExtrait => rectification !== null),
      ficheActe.mentions.map(Mention.depuisDto).filter((mention): mention is Mention => mention !== null),
      triListeObjetsSurPropriete(
        ficheActe.alerteActes.map(AlerteFicheActe.depuisDto).filter((alerte): alerte is AlerteFicheActe => alerte !== null),
        "dateCreation"
      ).reverse(),
      ficheActe.numero ?? null,
      registre,
      ficheActe.dateDerniereMaj ? DateRECE.depuisDateArrayDTO(ficheActe.dateDerniereMaj) : null,
      typeof ficheActe.dateDerniereDelivrance === "number" ? DateRECE.depuisTimestamp(ficheActe.dateDerniereDelivrance) : null,
      ficheActe.numeroBisTer ?? null,
      ficheActe.referenceRegistreSansNumeroDActe ?? null,
      ficheActe.evenement ?? null,
      ficheActe.detailMariage ? DetailMariage.depuisDto(ficheActe.detailMariage) : null,
      ficheActe.estReecrit ?? null,
      ficheActe.corpsTexte ?? null
    );
  };

  public readonly getAnalyseMarginaleLaPlusRecente = (): AnalyseMarginale | undefined => {
    if (!this.analysesMarginales.length) return undefined;

    const analysesMarginalesTriees: AnalyseMarginale[] = triListeObjetsSurDate([...this.analysesMarginales], "dateDebut").reverse();

    const analyseMarginaleLaPlusRecente = analysesMarginalesTriees.find(analyseMarginale => !analyseMarginale.dateFin?.estPassee());

    // si toutes les analyses marginales ont une date de fin révolue alors on prend la plus récente
    return analyseMarginaleLaPlusRecente ?? analysesMarginalesTriees[0];
  };

  public readonly getTitulairesAMDansLOrdreAvecMajDonneesTitulaireActe = (): TitulaireActe[] => {
    const analyseMarginale = this.getAnalyseMarginaleLaPlusRecente();

    if (!analyseMarginale) return [];

    const titulairesAMs: TitulaireActe[] = [];

    if (analyseMarginale.titulaires[0]) {
      titulairesAMs.push(analyseMarginale.titulaires[0].versTitulaireActe()!);

      titulairesAMs[0].majDeclarationConjointe(this.titulaires[0]);

      titulairesAMs[0].majNomSecable(this.titulaires[0]);
      titulairesAMs[0].majSexeAgeNaissanceEtFiliation(this.titulaires[0]);
    }

    if (analyseMarginale.titulaires[1]) {
      titulairesAMs.push(analyseMarginale.titulaires[1].versTitulaireActe()!);

      if (this.titulaires[1]) {
        titulairesAMs[1].majNomSecable(this.titulaires[1]);
        titulairesAMs[1].majSexeAgeNaissanceEtFiliation(this.titulaires[1]);
      }
    }

    return titulairesAMs;
  };

  public readonly aDonneesLieuOuAnneeEvenementAbsentes = (): boolean =>
    !this.evenement?.annee || (!this.evenement?.lieuReprise && !this.evenement?.ville && !this.evenement?.region && !this.evenement?.pays);

  public readonly estActeImageReecrit = (): boolean => Boolean(this.type === "IMAGE" && this.estReecrit && this.corpsTexte?.texte);

  public readonly estEnErreur = (): boolean => {
    switch (this.nature) {
      case "MARIAGE":
        return (
          this.titulaires[0]?.sexe === this.titulaires[1]?.sexe ||
          this.titulaires.some(titulaire => ["INCONNU", "INDETERMINE"].includes(titulaire.sexe))
        );
      case "NAISSANCE":
      case "DECES":
        return (
          this.titulaires[0].sexe === "INDETERMINE" ||
          this.titulaires[0].parentsSontDeMemeSexe() ||
          this.titulaires[0].aParentDeSexeIndetermine()
        );
      default:
        return false;
    }
  };

  public readonly estIncomplet = (): boolean => {
    switch (this.nature) {
      case "MARIAGE":
        return (
          this.titulaireAnalyseMarginaleLaPlusRecenteANomEtPrenomAbsent() ||
          this.aDonneesLieuOuAnneeEvenementAbsentes() ||
          this.titulaires.some(titulaire => titulaire.sexe === "INCONNU")
        );
      case "NAISSANCE":
      case "DECES":
        return (
          this.titulaireAnalyseMarginaleLaPlusRecenteANomEtPrenomAbsent() ||
          this.aDonneesLieuOuAnneeEvenementAbsentes() ||
          this.titulaires.some(titulaire => titulaire.sexe === "INCONNU") ||
          this.titulaires.some(titulaire => titulaire.aParentDeSexeInconnu())
        );
      default:
        return false;
    }
  };

  public readonly titulaireAnalyseMarginaleLaPlusRecenteANomEtPrenomAbsent = (): boolean => {
    const analyseMarginale = this.getAnalyseMarginaleLaPlusRecente();

    return analyseMarginale
      ? analyseMarginale.titulaires.some(
          titulaire => (!titulaire.nom && titulaire.prenoms.length === 0) || (titulaire.nom === SNP && titulaire.prenoms[0] === SPC)
        )
      : true;
  };

  public readonly necessiteMentionNationalite = (choixDelivrance?: ChoixDelivrance): boolean =>
    this.nature === "NAISSANCE" &&
    Boolean(this.registre) &&
    Boolean(this.registre && ["ACQ", "OP2", "OP3"].includes(this.registre?.famille)) &&
    (this.type === "TEXTE" || this.estActeImageReecrit()) &&
    !this.mentions.some(mention => mention.typeMention.natureMention?.code === NATIONALITE) &&
    ChoixDelivrance.estAvecFiliation(choixDelivrance);

  public readonly getMentionNationalite = (choixDelivrance?: ChoixDelivrance): IMentionMiseAJourDto[] => {
    if (!this.necessiteMentionNationalite(choixDelivrance)) return [];

    let max = 0;
    this.mentions?.forEach(mention => {
      if (mention.numeroOrdreExtrait) {
        max = max < mention.numeroOrdreExtrait ? mention.numeroOrdreExtrait : max;
      }
    });
    return [
      {
        numeroOrdreExtrait: max + 1,
        textes: {
          texteMentionDelivrance: extraireMentionNationalite(this.corpsTexte?.texte)
        },
        typeMention: {
          idTypeMention: TypeMention.getIdTypeMentionNationalitePourAjoutMentionDelivrance(),
          idNatureMention: NatureMention.depuisCode(NATIONALITE)?.id
        }
      }
    ];
  };

  public readonly getTitulairesPourAnalyseMarginale = () =>
    [...Array(this.getNombreTitulairesSelonNature()).keys()].map(index => this.getTitulairePourAnalyseMarginale(index));

  public readonly getTitulairePourAnalyseMarginale = (indexTitulaire: number) => {
    return this.getAnalyseMarginaleLaPlusRecente()?.titulaires[indexTitulaire]?.versTitulaireActe() ?? this.titulaires[indexTitulaire];
  };

  public readonly getNombreTitulairesSelonNature = () => {
    return this.nature === "MARIAGE" ? 2 : 1;
  };
}

const extraireMentionNationalite = (texte?: string): string => {
  if (!texte) return "Nationalite";

  const SOUS_LE_NOM = "sous le nom de";
  const SOUS_L_IDENTITE = "sous l'identité de";

  const regex = (() => {
    switch (true) {
      case texte.indexOf(SOUS_LE_NOM) !== -1:
        return /^(Français par|Française par)[:\s]+(.{1,750}?)sous le nom de[^(]*([^)]*?)$/gm; // NOSONAR catastrophic backtracking. Problème mitigé
      case texte.indexOf(SOUS_L_IDENTITE) !== -1:
        return /^(Français par|Française par)[:\s]+(.{1,750}?)sous l'identité de[^(]*([^)]*?)$/gm; // NOSONAR catastrophic backtracking. Problème mitigé
      default:
        return /^(Français par|Française par)[:\s]+(.{1,750})$/gm;
    }
  })();

  const result = regex.exec(texte);
  const partieMilieu = supprimeSautDeLigneEtEspaceInutiles(premiereLettreEnMinuscule(result?.[2]));
  const entreParenthese = supprimeSautDeLigneEtEspaceInutiles(result?.[3]?.concat(")"));

  return `${result?.[1]} ${partieMilieu} ${entreParenthese}`;
};
import { CONFIG_PATCH_COMPOSER_DOCUMENT_FINAL_DOUBLE_NUMERIQUE } from "@api/configurations/etatCivil/acte/PatchComposerDocumentFinalDoubleNumeriqueConfigApi";
import { CONFIG_PATCH_COMPOSER_DOCUMENT_MENTIONS_ULTERIEURES } from "@api/configurations/etatCivil/acte/PatchComposerDocumentMentionsUlterieuresConfigApi";
import { CONFIG_PATCH_INTEGRER_ACTE_DOUBLE_NUMERIQUE } from "@api/configurations/etatCivil/acte/PatchIntegrerActeDoubleNumeriqueConfigApi";
import { CONFIG_PATCH_INTEGRER_DOCUMENT_MENTION_SIGNER } from "@api/configurations/etatCivil/acte/PatchIntegrerDocumentMentionSigneConfigApi";
import { CONFIG_PATCH_COMPOSER_DOCUMENT_FINAL_PROJET_ACTE_ETABLI } from "@api/configurations/etatCivil/projetActe/PatchComposerDocumentFinalProjetActeEtabliConfigApi";
import { CONFIG_PATCH_COMPOSER_DOCUMENT_FINAL_PROJET_ACTE_TRANSCRIT } from "@api/configurations/etatCivil/projetActe/PatchComposerDocumentFinalProjetActeTranscritConfigApi";
import { CONFIG_PATCH_INTEGRER_DOCUMENT_FINAL_PROJET_ACTE_ETABLI } from "@api/configurations/etatCivil/projetActe/PatchIntegrerDocumentFinalProjetActeEtabliConfigApi";
import { CONFIG_PATCH_INTEGRER_DOCUMENT_FINAL_PROJET_ACTE_TRANSCRIT } from "@api/configurations/etatCivil/projetActe/PatchIntegrerDocumentFinalProjetActeTranscritConfigApi";
import { CONFIG_PATCH_STATUT_REQUETE_CREATION } from "@api/configurations/requete/creation/PatchStatutRequeteCreationConfigApi";
import { CONFIG_PATCH_STATUT_REQUETE_ETABLI_APRES_SIGNATURE } from "@api/configurations/requete/creation/PatchStatutRequeteEtabliApresSignatureConfigApi";
import { CONFIG_PATCH_STATUT_REQUETE_MISE_A_JOUR } from "@api/configurations/requete/miseAJour/PatchStatutRequeteMiseAjourConfigApi";
import { TErreurApi } from "@model/api/Api";
import { StatutRequete } from "@model/requete/enum/StatutRequete";
import { TypePopinSignature } from "@model/signature/ITypePopinSignature";
import CircularProgress from "@mui/material/CircularProgress";
import { useContext, useEffect, useMemo, useState } from "react";
import { RECEContextData } from "../../../contexts/RECEContextProvider";
import useFetchApi from "../../../hooks/api/FetchApiHook";
import Signature, { CODE_PIN_INVALIDE, IInformationsCarte } from "../../../utils/Signature";
import Bouton from "../bouton/Bouton";
import CodePinForm from "./CodePinForm";
import InformationsDeveloppeur from "./InformationsDeveloppeur";

type TStatutSignature =
  | "attente-pin"
  | "recuperation-informations"
  | "composition-document"
  | "signature-document"
  | "enregistrement-document"
  | "termine";

type TTypeSignature = "MISE_A_JOUR" | "DOUBLE_NUMERIQUE" | "ETABLI" | "TRANSCRIT";

interface IDonneesSignature {
  statut: TStatutSignature;
  codePin: string | null;
  erreurPin: boolean;
  erreur: string | null;
  informationsCarte: IInformationsCarte | null;
  documentASigner: string | null;
  documentSigne: string | null;
}

interface ISignatureCommunProps {
  idActe: string;
  idRequete: string;
  apresSignature: (succes: boolean) => void;
}

interface ISignatureMiseAJourProps extends ISignatureCommunProps {
  typeSignature: TTypeSignature;
  idSuivi?: never;
}

interface ISignatureEtablissementProps extends ISignatureCommunProps {
  typeSignature: TTypeSignature;
  idSuivi: string;
}

interface ISignatureTranscriptionProps extends ISignatureCommunProps {
  typeSignature: TTypeSignature;
  idSuivi?: never;
}

const DONNEES_SIGNATURE_DEFAUT: IDonneesSignature = {
  statut: "attente-pin",
  codePin: null,
  erreurPin: false,
  erreur: null,
  informationsCarte: null,
  documentASigner: null,
  documentSigne: null
};

const AVANCEMENT: { [EtatAvancement in Exclude<TStatutSignature, "attente-pin" | "termine">]: { niveau: number; message: string } } = {
  "recuperation-informations": { niveau: 0, message: "Récupération des informations de signature..." },
  "composition-document": { niveau: 33, message: "Génération du document à signer..." },
  "signature-document": { niveau: 66, message: "Signature du document..." },
  "enregistrement-document": { niveau: 100, message: "Enregistrement du document signé..." }
};

/* NOSONAR */ const SignatureDocument: React.FC<ISignatureMiseAJourProps | ISignatureEtablissementProps | ISignatureTranscriptionProps> = ({
  idActe,
  idRequete,
  apresSignature,
  typeSignature,
  idSuivi = null
}) => {
  const { utilisateurConnecte } = useContext(RECEContextData);

  const signature = useMemo(
    () => ({
      estMiseAJour: typeSignature === "MISE_A_JOUR" || typeSignature === "DOUBLE_NUMERIQUE",
      messageInformation: (() => {
        switch (typeSignature) {
          case "MISE_A_JOUR":
            return TypePopinSignature.getTextePopinSignatureMentions() ?? "";
          case "DOUBLE_NUMERIQUE":
            return TypePopinSignature.getTextePopinSignatureMentions() ?? "";
          case "ETABLI":
            return TypePopinSignature.getTextePopinSignatureActe() ?? "";
          case "TRANSCRIT":
            return TypePopinSignature.getTextePopinSignatureActeTranscrit() ?? "";
          default:
            return "";
        }
      })()
    }),
    [typeSignature]
  );

  const { appelApi: appelComposerMentions } = useFetchApi(CONFIG_PATCH_COMPOSER_DOCUMENT_MENTIONS_ULTERIEURES);
  const { appelApi: appelIntegrerMentions } = useFetchApi(CONFIG_PATCH_INTEGRER_DOCUMENT_MENTION_SIGNER);
  const { appelApi: appelModifierStatutRequeteMiseAJour } = useFetchApi(CONFIG_PATCH_STATUT_REQUETE_MISE_A_JOUR, true);

  const { appelApi: appelComposerActeDoubleNumerique } = useFetchApi(CONFIG_PATCH_COMPOSER_DOCUMENT_FINAL_DOUBLE_NUMERIQUE, true);
  const { appelApi: appelIntegrerActeDoubleNumerique } = useFetchApi(CONFIG_PATCH_INTEGRER_ACTE_DOUBLE_NUMERIQUE, true);

  const { appelApi: appelComposerProjetActeEtabli } = useFetchApi(CONFIG_PATCH_COMPOSER_DOCUMENT_FINAL_PROJET_ACTE_ETABLI);
  const { appelApi: appelIntegrerProjetActeEtabli } = useFetchApi(CONFIG_PATCH_INTEGRER_DOCUMENT_FINAL_PROJET_ACTE_ETABLI);
  const { appelApi: appelModifierStatutRequeteEtabli } = useFetchApi(CONFIG_PATCH_STATUT_REQUETE_ETABLI_APRES_SIGNATURE);

  const { appelApi: appelComposerProjetActeTranscrit } = useFetchApi(CONFIG_PATCH_COMPOSER_DOCUMENT_FINAL_PROJET_ACTE_TRANSCRIT);
  const { appelApi: appelIntegrerProjetActeTranscrit } = useFetchApi(CONFIG_PATCH_INTEGRER_DOCUMENT_FINAL_PROJET_ACTE_TRANSCRIT);
  const { appelApi: appelModifierStatutRequeteTranscrit } = useFetchApi(CONFIG_PATCH_STATUT_REQUETE_CREATION, true);

  const [donneesSignature, setDonneesSignature] = useState<IDonneesSignature>({ ...DONNEES_SIGNATURE_DEFAUT });

  const configurationSignature = {
    MISE_A_JOUR: {
      composer: appelComposerMentions,
      enregistrer: appelIntegrerMentions,
      modifierStatut: appelModifierStatutRequeteMiseAJour
    },
    DOUBLE_NUMERIQUE: {
      composer: appelComposerActeDoubleNumerique,
      enregistrer: appelIntegrerActeDoubleNumerique,
      modifierStatut: appelModifierStatutRequeteMiseAJour
    },
    ETABLI: {
      composer: appelComposerProjetActeEtabli,
      enregistrer: appelIntegrerProjetActeEtabli,
      modifierStatut: appelModifierStatutRequeteEtabli
    },
    TRANSCRIT: {
      composer: appelComposerProjetActeTranscrit,
      enregistrer: appelIntegrerProjetActeTranscrit,
      modifierStatut: appelModifierStatutRequeteTranscrit
    }
  } as const satisfies Record<TTypeSignature, unknown>;

  const recuperationInformations = () => {
    console.info("[SIGNATURE] Récupération des informations de la carte ...");
    donneesSignature.codePin &&
      Signature.recupererInformationsCarte({
        parametres: {
          idActe: idActe,
          codePin: donneesSignature.codePin,
          idAgent: utilisateurConnecte.id,
          prenomNomAgent: utilisateurConnecte.prenomNom,
          estMiseAJour: signature.estMiseAJour
        },
        apresSucces: informations => {
          console.info("[SIGNATURE] Récupération des informations de la carte effectuée");
          setDonneesSignature(prec => ({
            ...prec,
            informationsCarte: informations,
            statut: "composition-document"
          }));
        },
        apresErreur: erreur => {
          console.error(
            `[SIGNATURE] Erreur récupération des informations de la carte : ${erreur.code} - ${erreur.libelle} - ${erreur?.detail ?? "AUCUN DETAIL"}`
          );
          setDonneesSignature(prec => ({
            ...prec,
            erreur: erreur.libelle,
            erreurPin: erreur.code === CODE_PIN_INVALIDE,
            statut: erreur.code === CODE_PIN_INVALIDE ? "attente-pin" : "termine"
          }));
        }
      });
  };

  const compositionDocument = () => {
    console.info("[SIGNATURE] Composition du document à signer ...");

    if (!donneesSignature.informationsCarte) return;

    const config = configurationSignature[typeSignature];

    config.composer({
      parametres: {
        path: { idActe: idActe },
        body: {
          issuerCertificat: donneesSignature.informationsCarte.issuerCertificat,
          entiteCertificat: donneesSignature.informationsCarte.entiteCertificat
        }
      },
      apresSucces: documentASigner => {
        console.info("[SIGNATURE] Composition du document à signer effectuée");
        setDonneesSignature(prec => ({
          ...prec,
          documentASigner: documentASigner,
          statut: "signature-document"
        }));
      },
      apresErreur: erreurs => {
        const messageErreurServeur = ["FCT_16108", "TECH_16021"].includes(erreurs[0]?.code) ? erreurs[0]?.message : null;
        const messageErreurDefaut = "Erreur lors de la composition du document à signer";
        console.error(
          `[SIGNATURE] ${messageErreurDefaut} : ${erreurs[0]?.code ?? "CODE_INCONNU"} - ${erreurs[0]?.message ?? "Erreur inconnue"}`
        );

        setDonneesSignature(prec => ({
          ...prec,
          erreur: messageErreurServeur ?? messageErreurDefaut,
          statut: "termine"
        }));
      }
    });
  };

  const signatureDocument = () => {
    console.info(`[SIGNATURE] Signature du document ...`);
    donneesSignature.codePin &&
      donneesSignature.documentASigner &&
      Signature.signerDocument({
        parametres: {
          idActe: idActe,
          idAgent: utilisateurConnecte.id,
          document: donneesSignature.documentASigner,
          codePin: donneesSignature.codePin,
          estMiseAJour: signature.estMiseAJour
        },
        apresReponse: reponse => {
          const erreur = reponse.erreur?.libelle ?? null;
          const documentSigne = reponse.document ?? null;
          const messageErreur = !erreur && !documentSigne ? "Erreur inattendue" : erreur;
          messageErreur
            ? console.error(
                `[SIGNATURE] Erreur lors de la signature du document : ${reponse.erreur?.code ?? "CODE_INCONNU"} - ${messageErreur} - ${reponse.erreur?.detail ?? "AUCUN DETAIL"}`
              )
            : console.info(`[SIGNATURE] Signature du document effectuée`);

          setDonneesSignature(prec => ({
            ...prec,
            documentASigner: null,
            documentSigne: documentSigne,
            erreur: messageErreur,
            informationsCarte: reponse.infosSignature ?? null,
            statut: documentSigne ? "enregistrement-document" : "termine"
          }));
        }
      });
  };

  const enregistrementDocument = () => {
    console.info("[SIGNATURE] Enregistrement du document signé ...");

    if (!donneesSignature.documentSigne || !donneesSignature.informationsCarte) return;

    const config = configurationSignature[typeSignature];
    const parametresEnregistrement = {
      path: { idActe: idActe },
      body: {
        documentPadesBase64: donneesSignature.documentSigne,
        signature: donneesSignature.informationsCarte,
        modeAuthentification: "AROBAS_MDP" as const
      },
      ...(typeSignature === "DOUBLE_NUMERIQUE" ? { responseType: "blob" as const } : {})
    };

    config.enregistrer({
      parametres: parametresEnregistrement,
      apresSucces: () => {
        console.info("[SIGNATURE] Enregistrement du document signé effectué");
        console.info("[SIGNATURE] Modification du statut de la requête ...");

        const apresModificationStatut = {
          apresSucces: () => {
            console.info("[SIGNATURE] Modification du statut de la requête effectué");
            apresSignature(true);
          },
          apresErreur: (erreurs: TErreurApi[]) =>
            console.error(
              `[SIGNATURE] Erreur lors de la modification du statut de la requête : ${erreurs[0]?.code ?? "CODE_INCONNU"} - ${erreurs[0]?.message ?? "Erreur inconnue"}`
            ),
          finalement: () =>
            setDonneesSignature(prec => ({
              ...prec,
              statut: "termine"
            }))
        };

        switch (typeSignature) {
          case "MISE_A_JOUR":
          case "DOUBLE_NUMERIQUE":
            appelModifierStatutRequeteMiseAJour({
              parametres: { path: { idRequete: idRequete, statut: StatutRequete.TRAITEE_MIS_A_JOUR.nom } },
              ...apresModificationStatut
            });

            return;

          case "ETABLI":
            if (idSuivi?.length) {
              appelModifierStatutRequeteEtabli({
                parametres: { path: { idRequete: idRequete, idSuiviDossier: idSuivi ?? "" } },
                ...apresModificationStatut
              });
            } else {
              console.error("[SIGNATURE] Erreur lors de la modification du statut de la requête : ID Suivi inconnu");
              setDonneesSignature(prec => ({
                ...prec,
                statut: "termine"
              }));
            }

            return;

          case "TRANSCRIT":
            appelModifierStatutRequeteTranscrit({
              parametres: { path: { idRequete: idRequete }, query: { statut: StatutRequete.getKey(StatutRequete.TRAITE) } },
              ...apresModificationStatut
            });

            return;

          default:
            console.error(`[SIGNATURE] Type de signature inconnu : ${typeSignature}`);
            setDonneesSignature(prec => ({
              ...prec,
              statut: "termine"
            }));
            return;
        }
      },
      apresErreur: erreurs => {
        const messageErreurServeur = ["FCT_16108", "TECH_16021"].includes(erreurs[0]?.code) ? erreurs[0]?.message : null;
        const libelleEnregistrement =
          typeSignature === "DOUBLE_NUMERIQUE"
            ? "de l'acte double numérique signé"
            : signature.estMiseAJour
              ? "des mentions signées"
              : "de l'acte signé";
        const messageErreurDefaut = `Erreur lors de l'enregistrement ${libelleEnregistrement} `;
        console.error(
          `[SIGNATURE] ${messageErreurDefaut} : ${erreurs[0]?.code ?? "CODE_INCONNU"} - ${erreurs[0]?.message ?? "Erreur inconnue"}`
        );

        setDonneesSignature(prec => ({
          ...prec,
          erreur: messageErreurServeur ?? messageErreurDefaut,
          statut: "termine"
        }));
      }
    });
  };

  useEffect(() => {
    switch (donneesSignature.statut) {
      case "recuperation-informations":
        recuperationInformations();
        break;

      case "composition-document":
        compositionDocument();
        break;

      case "signature-document":
        signatureDocument();
        break;

      case "enregistrement-document":
        enregistrementDocument();
        break;
      default:
        break;
    }
  }, [donneesSignature.statut]);

  switch (donneesSignature.statut) {
    case "attente-pin":
      return (
        <>
          {signature.messageInformation && <div className="mb-4 text-start">{signature.messageInformation}</div>}

          <InformationsDeveloppeur />

          <CodePinForm
            onSubmit={codePin =>
              setDonneesSignature(prec => ({
                ...prec,
                codePin: codePin,
                erreurPin: false,
                statut: "recuperation-informations"
              }))
            }
            fermerModale={() => {
              setDonneesSignature({ ...DONNEES_SIGNATURE_DEFAUT });
              apresSignature(false);
            }}
            erreurPin={donneesSignature.erreurPin}
          />
        </>
      );

    case "recuperation-informations":
    case "composition-document":
    case "signature-document":
    case "enregistrement-document":
      return (
        <div>
          <div className="mt-1 h-2 w-full overflow-hidden rounded-full border border-solid border-gris">
            <div
              className="h-full bg-bleu"
              style={{
                width: `${AVANCEMENT[donneesSignature.statut].niveau}%`,
                transition: "width .4s ease"
              }}
            ></div>
          </div>

          <div className="text-center">{AVANCEMENT[donneesSignature.statut].message}</div>

          <div className="pt-4 text-center">
            <CircularProgress size={30} />
          </div>
        </div>
      );

    case "termine": {
      const estTypeSignatureMajOuEtabli = ["ETABLI", "MISE_A_JOUR"].includes(typeSignature);
      return (
        <div className="text-center">
          {donneesSignature.erreur && (
            <>
              <div className="font-bold text-rouge">{"⚠ Impossible d'effectuer la signature :"}</div>
              <div className="text-rouge">{donneesSignature.erreur}</div>
            </>
          )}

          {!donneesSignature.erreur && estTypeSignatureMajOuEtabli && <div>{"Signature des mentions effectuée."}</div>}

          {estTypeSignatureMajOuEtabli && (
            <Bouton
              className="mt-6"
              title="Fermer"
              styleBouton="principal"
              onClick={() => {
                setDonneesSignature({ ...DONNEES_SIGNATURE_DEFAUT });
                apresSignature(!donneesSignature.erreur);
              }}
            >
              {"Fermer"}
            </Bouton>
          )}

          {donneesSignature.erreur && !estTypeSignatureMajOuEtabli && (
            <div className="mt-6">
              <Bouton
                title="Réessayer"
                styleBouton="principal"
                onClick={() => {
                  setDonneesSignature({ ...DONNEES_SIGNATURE_DEFAUT });
                }}
              >
                {"Réessayer"}
              </Bouton>
            </div>
          )}
        </div>
      );
    }
    default:
      return <></>;
  }
};

export default SignatureDocument;
