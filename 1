import { CONFIG_POST_REQUETE_MISE_A_JOUR } from "@api/configurations/requete/miseAJour/PostRequeteMiseAJourApiConfig";
import { AddAlerteActeApiHookParameters, useAddAlerteActeApiHook } from "@hook/alertes/AddAlerteActeHookApi";
import { DeleteAlerteActeApiHookParameters, useDeleteAlerteActeApiHook } from "@hook/alertes/DeleteAlerteActeHookApi";
import { Droit } from "@model/agent/enum/Droit";
import { Perimetre } from "@model/agent/enum/Perimetre";
import { FicheActe } from "@model/etatcivil/acte/FicheActe";
import { ETypeActe } from "@model/etatcivil/enum/ETypeActe";
import { ETypeFiche } from "@model/etatcivil/enum/ETypeFiche";
import { EOptionMiseAJourActe, OptionMiseAJourActe } from "@model/etatcivil/enum/OptionMiseAJourActe";
import { TitulaireRequeteMiseAJour } from "@model/requete/ITitulaireRequeteMiseAJour";
import { SousTypeMiseAJour } from "@model/requete/enum/SousTypeMiseAJour";
import { UN } from "@util/Utils";
import { FeatureFlag } from "@util/featureFlag/FeatureFlag";
import { gestionnaireFeatureFlag } from "@util/featureFlag/gestionnaireFeatureFlag";
import { AccordionRece } from "@widget/accordion/AccordionRece";
import { IAjouterAlerteFormValue } from "@widget/alertes/ajouterAlerte/contenu/PopinAjouterAlertes";
import { OperationLocaleEnCours } from "@widget/attente/OperationLocaleEnCours";
import { BoutonMenu } from "@widget/boutonMenu/BoutonMenu";
import { BarreNavigationSuivPrec } from "@widget/navigation/barreNavigationSuivPrec/BarreNavigationSuivPrec";
import { SectionPanelProps } from "@widget/section/SectionPanel";
import { SectionPanelAreaProps } from "@widget/section/SectionPanelArea";
import React, { useCallback, useContext, useEffect, useMemo, useState } from "react";
import { useNavigate } from "react-router";
import { IFenetreExterneRef } from "../../../composants/commun/conteneurs/FenetreExterne";
import { RECEContextData } from "../../../contexts/RECEContextProvider";
import useFetchApi from "../../../hooks/api/FetchApiHook";
import LiensRECE from "../../../router/LiensRECE";
import {
  INFO_PAGE_MISE_A_JOUR_ANALYSE_MARGINALE,
  INFO_PAGE_MISE_A_JOUR_MENTION_AUTRE,
  INFO_PAGE_MISE_A_JOUR_MENTION_SUITE_AVIS
} from "../../../router/infoPages/InfoPagesEspaceMiseAJour";
import AfficherMessage from "../../../utils/AfficherMessage";
import { BoutonCreationRDD } from "./BoutonCreationRDD/BoutonCreationRDD";
import { setFiche } from "./FicheUtils";
import { BandeauAlertesActe } from "./contenu/BandeauAlertesActe";
import { BandeauFiche } from "./contenu/BandeauFiche";
import { BandeauFicheActeNumero } from "./contenu/BandeauFicheActeNumero";
import { BandeauFicheRcRcaPacsNumero } from "./contenu/BandeauFicheRcRcaPacsNumero";
import { useFichePageApiHook } from "./hook/FichePageApiHook";
import "./scss/FichePage.scss";

export interface IIndex {
  value: number;
}

interface IFichePageProps {
  datasFiches: IDataFicheProps[];
  index: IIndex;
  numeroRequete?: string;
  fenetreExterneRef?: IFenetreExterneRef;
  nbLignesTotales: number;
  nbLignesParAppel: number;
}

export interface IDataFicheProps {
  identifiant: string;
  categorie: ETypeFiche;
}

export const estActeEligibleFormuleDIntegration = ({
  origine,
  referenceActe,
  referenceRegistreSansNumeroDActe,
  type,
  mentions
}: FicheActe): boolean => {
  const estOrigineScecDocs = origine === "SCEC_DOCS";
  const referenceActePresente = Boolean(referenceActe?.trim());
  const referenceRegistreSansNumeroDActeAbsente = !referenceRegistreSansNumeroDActe?.trim();
  const estTypeTexte = type === ETypeActe.TEXTE;

  // Vérifier si l'acte a déjà été numérisé en cherchant la mention d'intégration
  const aDejaFormuleIntegration = mentions.some(mention => mention.textes?.texteMention?.includes("intégré au registre électronique"));

  return estOrigineScecDocs && referenceActePresente && referenceRegistreSansNumeroDActeAbsente && estTypeTexte && !aDejaFormuleIntegration;
};

export const FichePage: React.FC<IFichePageProps> = ({
  datasFiches,
  numeroRequete,
  index,
  fenetreExterneRef,
  nbLignesTotales,
  nbLignesParAppel
}) => {
  const navigate = useNavigate();
  const [actualisationInfosFiche, setActualisationInfosFiche] = useState<boolean>(false);
  const [ficheCourante, setFicheCourante] = useState<IDataFicheProps | undefined>(
    datasFiches[getIndexLocal(index.value, nbLignesParAppel)]
  );
  const [optionMiseAJour, setOptionMiseAJour] = useState<EOptionMiseAJourActe | null>(null);
  // index courant sur la totalité des données
  const [indexCourant, setIndexCourant] = useState<number>(index.value);

  const { appelApi: appelPostRequeteMiseAJour } = useFetchApi(CONFIG_POST_REQUETE_MISE_A_JOUR);

  useEffect(() => {
    setFicheCourante(datasFiches[getIndexLocal(indexCourant, nbLignesParAppel)]);
  }, [datasFiches]);

  // (*) Permet de résoudre le pb de la fenêtre fiche déjà ouverte
  // Si l'utilisateur clique sur une fenêtre fiche déjà ouverte (et qu'il a déjà navigué dedans) alors l'index aura changé (cf. onClickOnLine RMCTableauActes par exemple ),
  //   on peut ainsi mettre à jour l'index courant avec l'index passé en props
  // A noté que ce useEffect passe après le précédent et qu'il écrase donc la ficheCourante précédemment mise à jour par le useEffect ci-dessus
  useEffect(() => {
    setIndexCourant(index.value);
    setFicheCourante(datasFiches[getIndexLocal(index.value, nbLignesParAppel)]);
  }, [index]);

  const { utilisateurConnecte } = useContext(RECEContextData);

  const fiche = useFichePageApiHook(actualisationInfosFiche, ficheCourante?.categorie, ficheCourante?.identifiant);

  const { bandeauFiche, panelsFiche, alertes, visuBoutonAlertes } = setFiche(utilisateurConnecte, ficheCourante, fiche);

  const droitsMiseAJour = useMemo(() => {
    const droitMentions = utilisateurConnecte.estHabilitePour({ leDroit: Droit.METTRE_A_JOUR_ACTE });
    const droitAnalyseMarginale = utilisateurConnecte.estHabilitePour({ leDroit: Droit.MODIFIER_ANALYSE_MARGINALE });
    const droitCreationDoubleNumerique = utilisateurConnecte.estHabilitePour({ leDroit: Droit.MISE_A_JOUR_CREER_DOUBLE_NUMERIQUE });

    if (!fiche) {
      return {
        autorise: false,
        mentions: droitMentions,
        AnalyseMarginale: droitAnalyseMarginale
      };
    }

    let autorise = false;
    let peutMettreAJourSansRece = false;

    if (ficheCourante?.categorie === ETypeFiche.ACTE && "titulaires" in fiche && fiche.statut !== "BROUILLON") {
      const estOrigineRece = fiche?.origine === "RECE";
      const acteSansReceEligible = estActeEligibleFormuleDIntegration(fiche);
      // Acte SCEC_DOCS déjà numérisé (a la mention d'intégration)
      const estActeScecDocsNumerise = fiche?.origine === "SCEC_DOCS" && !acteSansReceEligible;

      peutMettreAJourSansRece = acteSansReceEligible && droitMentions && droitCreationDoubleNumerique;
      autorise =
        (estOrigineRece && (droitMentions || droitAnalyseMarginale)) ||
        peutMettreAJourSansRece ||
        (estActeScecDocsNumerise && droitMentions);
    }

    return {
      autorise,
      mentions: droitMentions || peutMettreAJourSansRece,
      AnalyseMarginale: droitAnalyseMarginale
    };
  }, [fiche, ficheCourante, utilisateurConnecte]);

  useEffect(() => {
    const idActe = fiche?.id;
    if (!optionMiseAJour || !idActe || !(fiche instanceof FicheActe)) return;

    const estAnalyseMarginale = optionMiseAJour === EOptionMiseAJourActe.ANALYSE_MARGINALE;
    const sousTypeOptionMiseAJour = OptionMiseAJourActe.getSousType(optionMiseAJour);

    appelPostRequeteMiseAJour({
      parametres: {
        body: {
          idActeMAJ: idActe,
          choixMAJ: estAnalyseMarginale ? "MAJ_ACTE_ANALYSE_MARGINALE" : "MAJ_ACTE_APPOSER_MENTION",
          sousType: sousTypeOptionMiseAJour.nom,
          titulaires: TitulaireRequeteMiseAJour.listeDepuisDonneesFiche(fiche.titulaires)
        }
      },
      apresSucces: reponse => {
        const urlNavigation = (() => {
          switch (true) {
            case estAnalyseMarginale:
              return LiensRECE.genererLien(INFO_PAGE_MISE_A_JOUR_ANALYSE_MARGINALE.url, {
                idRequeteParam: reponse.id,
                idActeParam: idActe
              });
            case SousTypeMiseAJour.estRMAC(sousTypeOptionMiseAJour):
              return LiensRECE.genererLien(INFO_PAGE_MISE_A_JOUR_MENTION_SUITE_AVIS.url, {
                idRequeteParam: reponse.id,
                idActeParam: idActe
              });
            default:
              return LiensRECE.genererLien(INFO_PAGE_MISE_A_JOUR_MENTION_AUTRE.url, { idRequeteParam: reponse.id, idActeParam: idActe });
          }
        })();

        navigate(urlNavigation);
      },
      apresErreur: erreurs => {
        const messageErreur = erreurs.find(erreur => erreur.code === "FCT_15181")?.message;

        AfficherMessage.erreur(messageErreur ?? "Impossible d'accéder à la requête de mise à jour de l'acte", {
          erreurs
        });
      },
      finalement: () => setOptionMiseAJour(null)
    });
  }, [optionMiseAJour]);

  // Obligatoire pour les styles qui sont chargés dynamiquement
  useEffect(() => {
    if (fiche && fiche.id === ficheCourante?.identifiant) {
      if (fiche != null) {
        const event = new CustomEvent("refreshStyles");
        if (window.top) {
          window.top.dispatchEvent(event);
        }
      }
      if (fenetreExterneRef && bandeauFiche) {
        fenetreExterneRef.ref.document.title = bandeauFiche.titreFenetre;
      }
    }
  }, [fiche, fenetreExterneRef, bandeauFiche, ficheCourante]);

  const setIndexFiche = useCallback(
    (idx: number) => {
      if (ficheCourante && datasFiches && idx >= 0 && idx < nbLignesTotales) {
        setFicheCourante(datasFiches[getIndexLocal(idx, nbLignesParAppel)]);
      }
      setIndexCourant(idx);
    },
    [ficheCourante, datasFiches, indexCourant, nbLignesParAppel, nbLignesTotales]
  );

  /* Ajout d'une alerte */
  const [ajouterAlerteActeApiHookParameters, setAjouterAlerteActeApiHookParameters] = useState<AddAlerteActeApiHookParameters>();

  const ajouterAlerteCallBack = useCallback(
    (value: IAjouterAlerteFormValue) => {
      setAjouterAlerteActeApiHookParameters({
        idActe: fiche?.id ?? "",
        idTypeAlerte: value?.idTypeAlerte,
        complementDescription: value?.complementDescription
      });
    },
    [fiche]
  );

  const alerte = useAddAlerteActeApiHook(ajouterAlerteActeApiHookParameters);

  /* Suppression d'une alerte */
  const [deleteAlerteActeApiHookParameters, setDeleteAlerteActeApiHookParameters] = useState<DeleteAlerteActeApiHookParameters>();

  const supprimerAlerteCallBack = useCallback((idAlerteActe: string, idActe: string) => {
    setDeleteAlerteActeApiHookParameters({
      idAlerteActe,
      idActe
    });
  }, []);

  const resultatSuppressionAlerte = useDeleteAlerteActeApiHook(deleteAlerteActeApiHookParameters);

  useEffect(() => {
    if (alerte || resultatSuppressionAlerte) {
      setActualisationInfosFiche(!actualisationInfosFiche);
    }
  }, [alerte, resultatSuppressionAlerte]);

  return (
    <div className="FichePage">
      {bandeauFiche && panelsFiche && fiche && ficheCourante ? (
        <>
          <BandeauFiche
            dataBandeau={bandeauFiche}
            elementNumeroLigne={
              ficheCourante.categorie === ETypeFiche.ACTE ? (
                <BandeauFicheActeNumero dataBandeau={bandeauFiche} />
              ) : (
                <BandeauFicheRcRcaPacsNumero dataBandeau={bandeauFiche} />
              )
            }
          />

          {datasFiches.length > UN && (
            <div className="barreNavigationSuivPrec">
              <BarreNavigationSuivPrec
                index={indexCourant}
                max={nbLignesTotales}
                setIndex={setIndexFiche}
              />
            </div>
          )}

          {fiche instanceof FicheActe && ficheCourante.categorie === ETypeFiche.ACTE && (
            <div className="headerFichePage">
              <BandeauAlertesActe
                alertes={alertes}
                idTypeRegistre={fiche?.registre?.type?.id}
                ajouterAlerteCallBack={ajouterAlerteCallBack}
                supprimerAlerteCallBack={supprimerAlerteCallBack}
                afficherBouton={visuBoutonAlertes}
                disableScrollLock={true}
              />
              {droitsMiseAJour.autorise && (
                <BoutonMenu
                  boutonLibelle="Mettre à jour"
                  className="menuMettreAJour"
                  options={OptionMiseAJourActe.commeOptions({
                    mentions: droitsMiseAJour.mentions,
                    analyseMarginale: droitsMiseAJour.AnalyseMarginale
                  })}
                  onClickOption={option => setOptionMiseAJour(option as EOptionMiseAJourActe)}
                  anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
                  transformOrigin={{ vertical: "top", horizontal: "right" }}
                  disableScrollLock={true}
                />
              )}
              {fiche &&
                !(
                  utilisateurConnecte.estHabilitePour({
                    leDroit: Droit.CONSULTER,
                    pourIdTypeRegistre: fiche.registre?.type?.id
                  }) || utilisateurConnecte.estHabilitePour({ leDroit: Droit.CONSULTER, surLePerimetre: Perimetre.TOUS_REGISTRES })
                ) &&
                gestionnaireFeatureFlag.estActif(FeatureFlag.FF_DELIVRANCE_CIBLE_EXTRAITS_COPIES) && (
                  <BoutonCreationRDD
                    label="Demander la délivrance"
                    labelPopin={`Vous allez demander la délivrance de cet acte. Souhaitez-vous continuer ?`}
                    acte={fiche}
                    numeroFonctionnel={numeroRequete}
                  />
                )}
            </div>
          )}

          {panelsFiche?.panels.map((panel: SectionPanelProps, idx: number) => (
            <AccordionRece
              key={`accordion-rece-${idx}`}
              panel={panel}
              index={idx}
              expanded={panelsFiche.panelParDefaut ? idx === panelsFiche.panelParDefaut : idx === 0}
              titre={panel?.title}
              disabled={panel?.panelAreas.every((pa: SectionPanelAreaProps) => !pa.value && !pa.parts)}
            />
          ))}
        </>
      ) : (
        <OperationLocaleEnCours visible={true} />
      )}
    </div>
  );
};

/**
 * Retourne l'index local à la "plage" courante (ie "datasFiches").
 * En effet, "indexCourant" est l'index sur la totalité des données mais dépasse peut être la taille de datasFiches
 */
function getIndexLocal(index: number, nbLignesParAppel: number) {
  return index % nbLignesParAppel;
}
